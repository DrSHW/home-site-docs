---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

# 元组、集合与类型转换

## 元组

元组可以算是一个特殊的列表：

+ 它有索引，和列表一样支持依据索引进行元素提取与切片提取，例如：

  ```python
  tuple1 = (1, 2, 3, (4, 5, 6, 7))
  print(tuple1[2])	# 3
  print(tuple1[0:3])	# (1, 2, 3)，切片得到的是元组类型
  print(tuple1[3][2])	# 6
  ```

+ 它同时是不可变类型，这意味着元组中的所有内容的地址`id`值**不能被修改**，具体来说就是：

  + 其中的不可变类型元素不可修改
  + 其中的可变类型元素`id`不能被修改，意味着你不能将其替换成别的元素，但你依然可以对这些元素内部进行修改

  举个例子：

  ```python
  t1 = (1, 2, 3, [4, 5, 6, 7], (8, 9))
  t1[0] = 8	# 错误，索引处对应元素为整型，不可变，无法修改
  t1[3][2] = 8	# 可修改，索引处对应元素为列表，修改其中的元素不会导致id值改变
  t1[3] = [4, 5, 6] 	# 错误，相当于重新定义了列表再将其赋值，元素的id值会改变，无法修改
  t1[4][1] = 10	# 错误，索引处对应元素为元组，子元组对应索引元素为整型，不可变，无法修改
  ```

  因为它的特性，它也不支持增加、删除、修改元素。

  一般在定义重要数据（如函数参数等 ）会使用它，防止数据被意外修改。

  你可以使用强制类型转换间接地修改它，后文会提及。

要注意的是，当元组只有一个元素时，必须在第一个元素之后加上逗号，否则括号将会被当作运算符解析，值将不会被判定为元组：

```python
a1 = (1)	# 错误写法
print(type(a1))	# <class 'int'>，括号作为运算符被解析，运算结果为整型
a2 = (1, )	# 在第一个元素之后加上逗号
print(type(a2))	# <class 'tuple'>，正确写法
```

## 集合

### 概述

集合主要用于进行**关系运算**（~~为数学服务~~ ）：

在第二节中，我们已经知道集合的性质——**互异性、无序性**

```python
print({'a', 'a'} == {'a'})	# True，有重复元素的集合与去重后的集合等价，证明其互异性
print({'a', 'b', 'c'} == {'c', 'b', 'a'})	# True，两集合相等，证明其无序性
```

无序性导致了集合不想列表那样具有索引，因此我们无法通过索引修改或是改变一个集合。

### 集合的运算

注意：在运算时，我们一般不考虑在集合中放一些可变类型的元素。

1. 交集 `&`

   取得两集合中相同的部分，例如：

   ```python
   s1 = {1, 3, 5, 7}
   s2 = {1, 2, 3, 4}
   print(s1 & s2)	# {1, 3}
   s3 = {1, 2}
   s4 = {3, 4}
   print(s3 & s4)	# set()，注意这里没有相同元素，返回一个空集合（set()表示空集合，{}表示空字典 ）
   ```

2. 并集 `|`

   取得集合所有的元素，例如：

   ```python
   s1 = {1, 3, 5, 7}
   s2 = {1, 2, 3, 4}
   print(s1 | s2)	# {1, 2, 3, 4, 5, 7}
   ```

3. 差集 `-`

   若有两集合`A`和`B`，`A - B`，表示`A`中去除`A`与`B` 交集的所有元素，即相较于集合`B`，`A`中特有的元素，例如：

   ```python
   s1 = {1, 3, 5, 7}
   s2 = {1, 2, 3, 4}
   print(s1 - s2)	# {5, 7}
   print(s2 - s1)	# {2, 4}
   ```

## 强制类型转换

强制类型转换可以使一个类型的变量转变为另一个类型的变量。

我们在字符串一节中提过，字符串类型可与数值类型互相转换，这种情况在所有的数据类型之间都可能发生。

这里列举一些常用的强制类型转换方式，基本格式均为`数据类型名(要转换的内容)`，可将内容转换为新数据类型。

1. `str()` 转换为字符串：

   + 将`list`变量转换为`str`：

     ```python
     l1 = ['My', 'Name', 'Is', 'DrSHW']
     strL1 = str(l1)
     print(strL1, type(strL1))	# ['My', 'Name', 'Is', 'DrSHW'] <class 'str'>
     ```

   + 将`tuple`变量转换为`str`：
   
     ```python
     t1 = ('My', 'Name', 'Is', 'DrSHW')
     strT1 = str(t1)
     print(strT1, type(strT1))	# ('My', 'Name', 'Is', 'DrSHW') <class 'str'>
     ```
   
   + 将`dict`变量转换为`str`：
   
     ```python
     d1 = {'name': 'DrSHW', 'age': 20}
     strD1 = str(d1)
     print(strD1, type(strD1))	# {'name': 'DrSHW', 'age': 20} <class 'str'>
     ```
   
2. `list()` 转换为列表：

   + 将`str`变量转换为`list`：

     ```python
     s1 = "DrSHW"
     listS1 = list(s1)
     print(listS1, type(listS1))	# ['D', 'r', 'S', 'H', 'W'] <class 'list'>
     ```

   + 将`tuple`变量转换为`list`：

     ```python
     t1 = ('My', 'Name', 'Is', 'DrSHW')
     listT1 = list(t1)
     print(listT1, type(listT1))	# ['My', 'Name', 'Is', 'DrSHW'] <class 'list'>
     ```

3. `tuple()` 转换为元组：

   + 将`str`变量转换为`tuple`：

     ```python
     s1 = "DrSHW"
     tupleS1 = list(s1)
     print(tupleS1, type(tupleS1))	# ('D', 'r', 'S', 'H', 'W') <class 'tuple'>
     ```

   + 将`tuple`变量转换为`list`：

     ```python
     l1 = ('My', 'Name', 'Is', 'DrSHW')
     tupleL1 = list(l1)
     print(tupleL1, type(tupleL1))	# (My', 'Name', 'Is', 'DrSHW') <class 'tuple'>
     ```

     有了`list`和`tuple`互相转换的功能，我们就能间接修改一个元组里的值，例如：

     ```python
     t1 = (1, 2, 3)	# 需求：将2修改为5
     l1 = list(t1)	# 将元组转换为列表，在列表中可进行修改
     l1[1] = 5	# 替换列表
     t1 = tuple(l1)	# 将替换后的列表转换为元组
     print(t1)	# (1)
     ```
     
   
4. `set()`转换为集合：

   + 将`list`变量转换为集合，由于集合的特性，可对列表元素进行**去重**，例如：

     ```python
     l1 = [1, 1, 2, 2, 3, 3]
     setL1 = set(l1)
     print(setL1, type(setL1))	# {1, 2, 3} <class 'set'>
     ```

     但是，**若列表中存在可变类型，则无法进行转换**。

   + `str`、`tuple`类型的转换同理，这里不举例了。