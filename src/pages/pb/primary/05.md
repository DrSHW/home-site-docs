---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

# 列表

## 列表元素提取

### 依据索引进行元素提取

从第二小节中，我们已经知道了列表是用于记录或存储多个值的数据结构.

和字符串相似，它也有相同的索引规则，支持按索引取值和切片取值，

其中列表切片后，返回的是一个子列表，例如：

```python
primes = [2, 3, 5, 7, 11, 13, 17, 19]
# 索引	 0  1  2  3  4   5   6   7
# 反向索引 -8 -7 -6 -5 -4  -3  -2  -1
print(primes[2])		# 3
print(primes[-3])		# 13
print(primes[0:3])		# [2, 3, 5]
print(primes[0:3:1])	# [2, 3, 5]
print(primes[1:6:2])	# [3, 7, 13]
print(primes[::-1])		# [19, 17, 13, 11, 7, 5, 3, 2]
print(primes[3::-1])	# [7, 5, 3, 2]
print(primes[3:0:-1])	# [7, 5, 3]
```

注意，与字符串一样，**索引值只能在合法范围**内，若超出则会产生列表索引越界错误。

### 嵌套列表的元素提取

如果一个父列表中嵌套了一个子列表，怎么获取子列表中的元素呢？

其实很简单，我们先用父列表的索引定位子列表的位置，再根据子列表的索引取出元素即可，例如：

```python
list1 = [1, 2, [9, 8, 7], "DrSHW"]
# 若想取出其中的8，字符D
print(list1[2])			# [9, 8, 7]先取出子列表
print(list1[2][1])		# 8 根据子列表的索引取出即可
print(list[3][0])		# 0 字符串也是一样
```

在后面的学习中经常会遇到嵌套的情况，无论是套什么（即使是后面的字典元组），一层一层地提取即可。

列表的长度和字符串一样，也可以通过`len(列表名)`获取，例如：

```python
list1 = [1, 2, [9, 8, 7], "DrSHW"]
print(len(list1))		# 4，一共四个元素，长度为4
```

## 列表元素查找

1. 查找元素是否在列表中，使用`in`/`not in`关键字即可，返回一个布尔值，例如：

   ```python
   L = ['DrSHW',1,1.2,[1.22,'LJJ']]
   print('DrSHW' in L)			# True
   print('DrSHW' not in L)		# False
   print('LJJ' in L)			# False，不要将嵌套列表中的元素和原列表中的元素混淆
   print('LJJ' in L[3])		# True
   print([1.22, 'LJJ'] in L)	# True
   ```
   
2. 若想知道列表中包含多少个某元素，可使用`count()`方法，例如：

   ```python
   L = [1, 2, 2, 3, 3, '3']
   print(L.count(2))		# 2
   print(L.count(3))		# 2, 注意3与'3'不同
   ```

3. 若要查找某元素的具体位置，使用`index()`方法（列表**不支持**`find()`方法），和字符串查找相似，例如：

   ```python
   L = ["Jie", "Van", "Billy"]
   print(L.index("Van"))		# 1
   print(L.index("DIO"))		# 找不到，报错
   ```

## 列表元素的添加

1. 在列表最后添加单个元素，可使用`append(元素值)`方法，由于L是可变类型，可以在其中添加元素，且其地址`id`不变，例如：

   ```python
   L = [1, 2]
   print(id(L))
   L.append(3)				# 加入一个整型数3
   print(L)				# [1, 2, 3]
   print(id(L))			# 两次id相等
   L.append([4, 5])		# 加入一个列表元素，该列表成为原列表的一个字列表
   print(L)				# [1, 2, 3, [4, 5]]
   ```

2. 在列表指定索引处添加一个元素，可使用`insert(索引, 元素值)`方法，例如：

   ```python
   L = [1, 2, 3, 4, 5]
   L.insert(3, 'flag')		# 在索引值为3的位置，即原先元素'4'的位置添加新元素
   print(L)				# [1, 2, 3, 'flag', 4, 5]
   ```

3. 添加多个元素，可使用`extend([元素1, 元素2, ...])`方法，传入一个自定义列表，程序会将自定义列表中的元素追加在列表最后，例如：

   ```python
   L = [1, 2]
   L.extend([1, 2])		# 加入两个元素1, 2
   print(L)				# [1, 2, 1, 2]
   L.extend([3, [4, 5]])	# 加入两个元素3, [4, 5]
   print(L)				# [1, 2, 1, 2, 3, [4, 5]]
   ```

## 列表删除

### 列表的删除

+ 直接`del 列表名`即可，不多说

### 列表元素的删除 

1. 删除单个元素

   + 若想删除列表最后一个元素，可使用`pop()`方法，例如

     ```python
     list1 = [1, 2, 3]
     list1.pop()
     print(list1)	# [1, 2]
     list1.pop()
     print(list1)	# [1]
     ```

   + 若想删除指定索引的元素，可通过`del 列表名[索引值]`实现，例如：

     ```python
     list1 = [1, 2, 3, 4, 5]
     del list[2] 		# 删除索引值为2的元素3
     print(list)			# [1, 2, 4, 5]
     del list[3]			# 删除索引值为3的元素5（列表已更新）
     print(list)			# [1, 2, 4]
     ```

2. 清空一个列表

   可通过`clear()`方法实现，例如：

   ```python
   list1 = [1, 2, 3, 4, 5]
   list1.clear()		# 清空list1的所有元素
   print(list1)		# []
   ```

## 列表元素的修改

1. 列表支持根据索引修改元素，例如：

   ```python
   list1 = [1, 2, 3, 4, 5]
   list1[2] = 999			# 将索引值为2的元素改为999
   list1[-1] = 666			# 将索引值为-1的元素改为666
   print(list1)			# [1, 2, 999, 4, 666]
   ```

2. 若要将列表的元素反序，可使用`reverse()`方法，由于是可变类型，反序后会修改原值，例如：

   ```python
   list1 = [1, 2, 3, 4, 5]
   list1.reverse()			# 将list1反序
   print(list1)			# [5, 4, 3, 2, 1]
   ```

3. 若要将列表排序，可以使用`sort()`方法，可以传入一个布尔型参数`reverse`，默认为`reverse=False`；

   `reverse=True`时，倒序排序，`reverse=False`时（即默认情况），正序排序，例如：

   ```python
   list1 = [1, 3, 2, 5]
   list1.sort()				# 默认正序排序
   print(list1)				# [1, 2, 3, 5]
   list2 = [1, 3, 2, 5]
   list2.sort(reverse=False)	# 正序排序
   print(list2)				# [1, 2, 3, 5]
   list3 = [1, 3, 2, 5]
   list3.sort(reverse=True)	# 倒序排序
   print(list3)				# [5, 3, 2, 1]
   ```

## 可变类型原理

我们都知道，对于可变类型的变量，值不变化并不影响其地址`id`的变化。

其实是由于定义每一个可变类型变量时，系统都会分配一块内存给该变量，用于存储地址（类似C语言的指针数组）。

即使是两个完全相等的可变类型变量，系统也会给他们分配内存，若执行以下代码：

```python
L1 = [3, "abc"]
L2 = [3, "abc"]
print(id(L1))		# Ad 1，代表L1的地址
print(id(L2))		# Ad 2，代表L2的地址，虽然值相同，但是地址不同
```

执行后，内存会新增以下内容：

![image-20220708194811532](https://images.maiquer.tech/images/wx/image-20220708194811532.png)

如上图所示，两个内容完全相等的列表，地址不同。

再举个例子：

```python
print([] is [])		# False，两空列表地址不同 
```

所以，当一个列表中新增了元素或删除了元素时，其地址`id`也不会变化，执行以下语句：

```python
L1 = [3, 'abc']
print(id(L1))		# Ad 1
L1.append(127)
print(id(L1))		# Ad 1，无变化
```

内存的变化如下：

![image-20220708200114980](https://images.maiquer.tech/images/wx/image-20220708200114980.png)`L1`的地址没有变化。

+ 思考：执行以下代码，打印的结果是什么？

```python
a = []
a.append(a)
print(a)
```

答案很奇异，为一个无线嵌套自身的列表：`[[...]]`

我们从执行后的内存图即可看出原因：

![image-20220708204537587](https://images.maiquer.tech/images/wx/image-20220708204537587.png)

列表中的每个元素都指向了同一个列表地址，同一个列表地址中的内容是一致的（虽然数值改变不会影响地址，但是地址一旦确定，值就一定能确定），所以每个子元素都会嵌套自己，构成了无限循环。
