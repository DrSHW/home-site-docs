---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

# 字符编码与内存读写

## 字符编码

### 什么是字符编码

计算机要想工作必须通电，即用‘电’驱使计算机干活，也就是说‘电’的特性决定了计算机的特性。

电的特性即高低电平（人类从逻辑上将二进制数`1`对应高电平，二进制数`0`对应低电平 ）。一位二进制数可包括`0, 1`两种状态，那么2位二进制数可以表示的信息就有 `00, 01, 10, 11` 4种状态，那么3位二进制数可以表示的信息就有 `000, 001, 010, 011, 100, 101, 110, 111` 8种状态。

所以，我们平时在使用计算机时，使用的字符本质上都是**二进制数**转换而来的。这些二进制数我们称之为**字节码**，字符编码的过程其实就是：将我们能看懂的**字符串**编码成**字节码**的过程，而解码过程正好相反：

  	字符-------- 编码 ------->二进制
  	字符<------- 解码 --------二进制

这个过程实际就是一个字符如何对应一个特定数字的标准，这个标准称之为**字符编码**。

### 字符编码的分类

1. 英文编码

   + **ASCII码**

     ASCII码用1个字节（8位二进制 ）代表一个二进制字符，所以，ASCII码最多只能表示 256 (2**8 = 256)个符号。

     最早的字符编码为ASCII，只规定了英文字母数字和一些特殊字符与数字的对应关系（无法表示中文 ）。

2. 中文编码

   + **GB2312**

     由于ASCII无法表示中文，而一个字节只能表示128个字符，远远少于汉字的个数。

     所以中国人规定了自己的标准GB2312编码，规定了包含中文在内的`字符－>数字`的对应关系。

     GB2312编码对所收录字符进行了“分区”处理（区位码 ），共94个区，每区含有94个位，共8836个码位，足够表示大部分汉字。

   + **GBK**国标码

     GB 2312的出现，基本满足了汉字的计算机处理需要，但对于人名、古汉语等方面出现的罕用字，GB 2312不能处理。

     这导致了后来GBK汉字字符集的出现，又称国标码。GBK在GB2312标准基础上进行扩展，使用两个字节编码一个汉字，其编码范围从8140至FEFE，共23940个码位，表示所有汉字绰绰有余。

3. 其他语言编码

   +  Shift_JIS

     日本人规定了自己的Shift_JIS编码。

   + Euc-kr

     韩国人规定了自己的Euc-kr编码（另外，韩国人说，要求世界统一用韩国编码，但世界人民没有搭理他们 ）

4. 统一码/万国码

   + **Unicode**

     尽管每个国家都有自己语言的编码方式，但是由于各个国家对字符的编码时并没有考虑其他国家，如果单纯采用一种国家的编码格式，那么其余国家语言的文字在解析时就会出现乱码。所以迫切需要一个世界的标准（能包含全世界的语言 ）于是Unicode应运而生。

     Unicode不仅兼容ASCII码，也兼容世界上大部分国家的编码集，解决了乱码问题。

     Unicode译码表存储在电脑**内存**中，常用2个字节（16位二进制 ）代表一个字符，而生僻字需要用4个字节（32位二进制 ）表示。

     这就出现了一个新问题，如果我们的文档通篇都是英文，如果用Unicode编码会比ascii耗费多一倍的空间，在存储和传输上十分的低效。

   + **UTF-8**

     为了解决传输低效的问题，出现了把Unicode编码转化为“可变长编码”的UTF-8(Unicode Transformation Format)编码。

     UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。 一些字符的对应关系如下：

     | 字符 | ASCII    | Unicode                    | UTF-8                      |
     | ---- | -------- | -------------------------- | -------------------------- |
     | A    | 01000001 | 00000000 01000001          | 01000001                   |
     | 中   | 没有     | 11100100 01001110 00101101 | 11100100 10111000 10101101 |

     简单来说，英文字母 UTF-8 使用的和 ASCII 对应关系一样， 而中文 UTF-8 使用 Unicode 对应关系一样。

     UTF-8译码表一般存放在**硬盘**中。

   + Unicode与UTF-8的关系

     1. 在存入磁盘时，需要按照UTF-8标准将Unicode转成一种更为精准的格式；
     2. 在读入内存时，需要按照Unicode标准将UTF-8转成可被大部分程序识别的编码。

     所以我们需要明确：内存中用Unicode是为了兼容万国软件，即便是硬盘中有各国编码编写的软件，Unicode也有相对应的映射关系。但在现在的开发中，程序员已经普遍使用UTF-8编码了。估计在将来的某一天等所有老的软件都淘汰掉了情况下，就可以变成：`内存Unicode<->硬盘UTF-8`的形式了。

### 编码和解码

我们可以通过`encode/decode`来完成字节码和字符串的转换，`encode`返回二进制数据，`decode`返回字符串，格式为：

```python
字符串.encode(encoding=编码方案, errors=错误处理方案)
二进制数据.decode
```

其中的`encoding`是指在解码编码过程中使用的编码方案(默认为UTF-8)，`errors`是指错误的处理方案，一般省略不写，示例：

```python
text = "我是文本"
b_text = text.encode(encoding='gb2312')
print(b_text)	# b'\xce\xd2\xca\xc7\xce\xc4\xb1\xbe'，编码为二进制数据
print(b_text.decode(decoding='gb2312'))	# 我是文本，解码为字符串
```

对于文件乱码现象，我们在下一节中讲解。

### 回顾

 在**函数初步**一节中，Python中内置了`ord()/chr()`函数 ，就是用来转换编码与数值的。

它可将编码与字符依照`Unicode`编码表进行转换，这意味着它能转换中文字符：

```python
print(ord('中'))	# 20013
print(chr(20013))	# 中
```

看完这节后，你对其应该会有更深的理解了。

## 内存读写

很多时候，少量数据交互会在主机内存中读写，而大量的数据传输则需要进行文件读写。

我们可以使用`io`模块的`StringIO`和`BytesIO`进行内存读写操作。

### StringIO

顾名思义，`StringIO`就是在内存中读写字符串`str`。

要把字符串写入`StringIO`，我们需要先创建一个`StringIO`对象`f`，然后调用它的`write`方法即可，返回成功写入的字符个数；

可以多次`write`，会被保存在`f`中，可通过`f.getvalue()`获取，返回其中的值，示例：

```python
from io import StringIO
f = StringIO()
print(f.write('hello')) 	# 5
f.write(' ')
f.write('world!')
print(f.getvalue())	# hello world!
```

要读取`StringIO`，可以用一个字符串（可多行）初始化`StringIO`，然后调用它的`readline`方法，以字符串返回一行的数据：

```python
from io import StringIO

str = '''
Hello!
Hi!
Goodbye!
'''
f = StringIO(str)
while True:
    s = f.readline()
    if s == '':
        break
    print(s.strip())
```

### BytesIO

`StringIO`操作的只能是字符串，如果要操作二进制数据，就需要使用`BytesIO`。

`BytesIO`实现了在内存中读写二进制数据，我们创建一个`BytesIO`对象`f`，然后使用`f.write()`写入一些二进制数据：

```python
from io import BytesIO
f = BytesIO()
print(f.write('中文'.encode('utf-8'))) 	# 6
print(f.getvalue())	# b'\xe4\xb8\xad\xe6\x96\x87'
```

请注意，写入的不是字符串，字符串而是经过UTF-8编码的二进制数据。

和`StringIO`类似，可以用一串二进制数据初始化`BytesIO`对象`f`，然后使用`f.read()`进行读取：

```python
from io import BytesIO
f = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')
print(f.read())	# b'\xe4\xb8\xad\xe6\x96\x87'
```

### 小结

`StringIO`和`BytesIO`是在内存中操作字符串和二进制数据的方法，使得和读写文件具有一致的接口。

​                

​                

