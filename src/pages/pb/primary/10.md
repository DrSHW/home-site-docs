---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

# 函数高级

## 匿名函数

### 概述

我们之前接触到的函数，都具有函数名这种属性，称之为有名函数。

而匿名函数就是没有函数名的函数，用于仅仅临时使用一次的场景，没有重复使用需求的情况。

匿名函数又称`lambda`表达式，虽然没有名字，匿名函数也包括了函数的三要素。

### 定义

定义格式如下：

```python
lambda 参数列表 : 表达式或其他函数调用
```

其中参数与有名函数的要求一致，返回值则**表达式的运算结果**或其他函数返回值，例如：

```python
lambda x, y : x + y				# 两个参数x、y，返回x + y
lambda : print("Hello")			# 无参数，返回None
# 错误示范
lambda x, y : x = 1				# 错误，x = 1不是一个表达式，没有计算结果
```

和有名参数一样，定义匿名函数就是在内存中开辟了存储空间。我们打印一个匿名函数：

```python
print(lambda x, y : x + y)		# <function <lambda> at 0x000001DC0430F160>
```

`0x000001DC0430F160`即为匿名函数的地址。

### 调用（一般不会这么做 ）

与有名函数一样，通过函数的地址，即可调用函数。

方法一：直接调用

在函数后打括号传参即可，例如：

```python
print((lambda x, y : x + y)(1, 2))			# 3
(lambda : print("Hello"))()					# Hello
```

方法二：赋值调用

上一章中我们提到，函数名只是对内存地址的引用，真正起作用的是那块内存地址，

所以我们只要给匿名函数创建一个函数名，它就和有名函数一模一样了，例如：

```python
# 取较小值
f = lambda x, y : x if x < y else y		# 将函数的地址赋值给变量f，创建函数名
print(f(3, 4))							# 3，通过f也可以调用
```

虽然可以这么做，但是匿名函数的精髓就是没有名字，为其绑定名字是**没有意义**的。

### 使用场景

一般作为参数传递给其他函数，可以和上一节提到的内置函数配合使用。

举个例子，若有一个字典`salaries`，`key`代表人名，`value`代表工资：

```python
salaries = {
    'DrSHW': 1500,
    'ljj': 2400,
    'Dustella': 3000
}
```

我们想通过聚合函数求取最小值等信息时，若直接按如下方式调用，会出现问题：

```python
print(min(salaries))		# DrSHW，打印结果为key的最小值
```

聚合函数在对字典进行运算时，默认比较其中的`key`值，而我们要计算的是薪资最低的人名，即比较`value`的值确定人名。

这时我们就需要告诉程序我们比较的是`value`，可以通过**传递函数**的方式进行。

定义这样一个函数：

```python
# 获得字典的value
def func(n):
    return salaries[n]
```

可以将这个函数传递给聚合函数的参数`key`，这样就可以按`value`比较：

```python
print(max(salaries,key=func))		# ljj，注意此时传递的是函数名，即函数本身。若加了括号，就意味着传递函数的返回值
```

此时返回的就是薪资最低的人名。

而这个`func`的函数的传入，就可以用匿名函数传值代替。因为`func`几乎不会在程序的其他地方使用、

求取`salaries`的薪资最高、最低的人名以及薪资总和，可以直接采用以下代码，无需重新定义`func`：

```python
# 求薪资最高是谁
print(max(salaries,key=lambda n:salaries[n]))		# Dustella
# 求薪资最低是谁
print(min(salaries,key=lambda n:salaries[n]))		# ljj
# 求薪资总和
print(sum(salaries.values()))		# 7500，反正最后算的也是值，不是人名，我们直接传入values即可
```

上一节中学到的`sorted`也可与之配合：

若我们只想对薪资进行值排序，那么直接：

```python
res = sorted(salaries.values())
print(res)				# [2000, 2500, 3000]
```

如果我们需要按薪资排序的人名，就需要传递匿名比较函数：

```python
# 升序按薪资排列人名
res = sorted(salaries, key=lambda n : salaries[n])
print(res)				# ['ljj', 'DrSHW', 'Dustella']
# 降序也是一样
rev_res = sorted(salaries, key=lambda n : salaries[n], reverse=True)	
print(rev_res)			# ['Dustella', 'DrSHW', 'ljj']
```

后面类似这样的应用场景还有很多，会结合后面的知识点进行说明。

## 递归函数

函数的递归调用是函数嵌套调用的一种特殊形式，在调用一个函数的过程中又直接或者间接地调用该函数本身，称之为函数的递归调用。

递归调用必须有两个明确的阶段:

1. 回溯: 一层层递归调用下去，说白了就一个重复的过程。

   但需要注意的是每一次重复问题的规模都应该有所减少，直到逼近一个最终的结果，即回溯阶段一定要有一个明确的**结束条件**。

2. 递推: 往回一层一层推算出结果。

如最经典的递归问题，求斐波那契数列的第n项：

斐波那契数列第`n`项`f(n)`满足：`f(1) = 1, f(2) = 1, f(n) = f(n - 1) + f(n - 2) (n > 2) `

那么它就可以写成一个递归函数：

```python
def f(n):
    # 相当于结束条件
    if n == 1:
        return 1
    if n == 2:
        return 1
    # 每次减少规模
    return f(n - 1) + f(n - 2)
print(f(5))			# 5
```

它的运作过程如下：

回溯阶段：

![image-20220714160329097](https://images.maiquer.tech/images/wx/image-20220714160329097.png)

递推阶段：

```matlab
f(1) = 1
f(2) = 1
f(3) = 1 + 1 = 2
f(4) = f(3) + f(2) = 2 + 1 = 3
f(5) = f(3) + f(4) = 5
```

再举个例子，打印列表`L = [1, [2, [3, [4, [5, [6, [7, [8, [9, ]]]]]]]]]`里的所有数值：

我们发现，最大的列表中只有两个元素，一个为数值，一个为子列表；而子列表中的构造也为数值+子列表。

我们只需遍历这个列表，若为数值类型，打印即可；否则递归执行下一个列表，直到列表中没有列表类型，代码如下：

```python
def f(L):
    for n in L:
        if type(n) is int:
            print(n, end=' ')
        else:
            f(n)
L = [1,[2,[3,[4,[5,[6,[7,[8,[9,]]]]]]]]]
f(L)			# 1 2 3 4 5 6 7 8 9
```

递归在深度优先遍历(DFS)等算法中使用非常广泛，这里对其作初步了解即可。

## 函数的嵌套定义

### 定义

Python中支持函数的嵌套，即在函数内部定义一个新函数。

程序外部无法直接访问内层函数，所以你必须能够通过一些手段调用内层的函数，否则这个嵌套是无意义的，例如：

```python
# 正确案例
def func1():
    print("func1")
    def func2():		# 定义内层函数，和普通的定义一样，但是
        print("func2")
    func2()				# 在外层函数中直接调用了内层函数
func1()
# func2()				# 报错，程序外部无法直接访问内层函数

# 无意义案例
def func1():
    print("func1")
    def func2():		# 定义内层函数，和普通的定义一样，但是
        print("func2")
func1()					# 内层函数从未被使用，无意义
```

嵌套函数中，内层函数默认共享外层函数的所有参数，例如：

```python
def func1(n):
    def func2():		# 定义内层函数，和普通的定义一样，但是
        print(n)
    func2()				# 在外层函数中直接调用了内层函数
func1(10)				# 10，说明内层函数可以访问外层函数的参数
```

若不加声明，内层函数无法获取到外层函数定义的变量：

```python
def func1():
    b = 100
    def func2():
        b += 1			# 报错，无法获取b
        print(b)
    func3()
```

若要使用，需要用`nonlocal`关键字进行声明，上面的程序改为：

```python
def func2():
    b = 100
    def func3():
        nonlocal b		# nonlocal进行声明
        b += 1
        print(b)
    func3()
func2()					# 101
```

### 闭包

Python中函数的嵌套，一般以**闭包**的形式出现，所谓闭包：

+ 闭指的是：该函数是一个**内部函数**

+ 包指的是：指的是该内部的函数名字在外部被**引用**

定义格式如下：

```python
def 外层函数名(外层参数列表):
    代码体
    def 内层函数名(内层参数列表):
        代码体
    代码体
    return 内层函数名
```

其中最重要的，就是**外层函数返回内层函数名**，本质上是返回内层函数的**地址**。

调用内层函数有两种方式，以下方闭包函数为例：

```python
def outer():
    print("这是外层闭包函数")
    def inner():
        print("这是内层闭包函数")
    return inner
```

+ 方式一：一层层调用

  ```python
  inner = outer()			# 打印 这是外层闭包函数，返回内层函数地址，再用变量接收内层函数
  inner()					# 打印 这是内层闭包函数，调用内层函数
  ```

+ 方式二：匿名调用

  ```python
  outer()()				# outer()返回了inner的地址，outer()()本质上就是调用了inner的地址
  ```

  通常不这么写，不规范。

除了传统的参数传递，我们也可以用闭包函数进行参数传递：

```python
# 传统的参数传递
def add(a, b):
    return a + b
add(3, 2)
add(3, 2)
add(3, 2)		# 传递相同的参数，写了三遍，我们除了可以用默认形参优化这一点，也可以采用闭包函数
# 闭包传参
def outer(a, b):
    def func():		# 由于是共享参数，这里无需再写形参(a, b)了，写了会覆盖外层的a、b
        print(a + b)
    return func
add = outer(3, 2)	# 相当于把参数(3, 2)渗透到func的地址里了，再将地址赋值给add变量，使之成为对改变后地址的引用
add()
add()
add()				# 三次都打印5，说明参数传递成功
```

内层函数也可以有自己的参数，在内层函数参数列表添加即可，例如：

```python
def outer(a):
    def func(b):		# 由于是共享参数，这里无需再写形参(a, b)了，写了会覆盖外层的a、b
        print(a + b)
    return func
add = outer(3)			# 先传入a，内层函数所有的a都会被赋值
add(2)					# 打印5，再传入内层函数的特有参数b，即可
```

### 装饰器

装饰器是一种特殊的闭包函数，作用是为其他函数添加一些额外的功能。

#### 为什么要用装饰器？

软件的维护应该遵循**开放封闭原则**，即：

+ 软件一旦上线运行后对**修改源代码**是**封闭**的，对**扩展功能**的是**开放**的。

装饰器的要求要高于闭包，装饰器的实现必须遵循两大原则：

        1. 不修改被装饰对象的**源代码**
        1. 不修改被装饰对象的**调用方式**

#### 使用

若已经封装好了一个函数`func`，下面对`func`的装饰器定义和调用过程如下：

```python
# 定义
def 装饰器名(已封装的函数名):				# 传入一个函数
    def 内层函数名(已封装函数的参数列表):
        额外代码						# 额外功能
        已封装的函数名(传入的参数)			# 调用封装的函数
        额外代码						# 额外功能
	return 内层函数名
# 调用
新函数名称 = 装饰器名(func)		 # 传入封装好的函数
新函数名称(传入func所需参数)      # 普通的传参调用即可
```

可以看出一些特点：

1. 传入外层函数的是**函数名**；
2. 和闭包函数一样，外层函数返回的是内层函数的**地址**；
3. 额外功能和函数的执行定义在**内层函数**中；

装饰器定义好后，可以在需要装饰的函数上方标注`@装饰器名`，以使用新的函数，例如：

```python
# 定义装饰器decorator，作用是在原函数的基础上打印两段话
def decorator(func):
    def new_func():
        print("前面的代码")
        func()
        print("后面的代码")
    return new_func

# 一般装饰器的使用方式：
# 1. 定义一个需要装饰的函数
def func():
    print('Hello')
# 2. 将函数传入装饰器，取出新函数的内存地址
decorated_func = decorator(func)
# 3. 直接调用
decorated_func()

# 可使用@+装饰器名简化调用操作：
# 1. 定义一个需要装饰器的函数，并附上装饰器
@decorator
def func():
    print('Hello')
# 2. 直接调用func即可
func()
# 执行结果一样
```

#### 实际案例

下面我们举一个装饰器的常用案例——程序计时器：

Python中内置了`datetime`模块，其中的`datetime.now()`会返回当前的时刻，我们的需求是在程序执行完之前**打印执行的时间**。

（关于**模块**，具体的内容会在**Python面向对象**一章中的**模块**一节详细讲解 ）

执行的时间只要计算`程序执行后的时刻 - 程序执行前的时刻`即可，先导入模块并定义一个装饰器`run_time`：

```python
from datetime import datetime
def run_time(func):  						# 定义装饰器，传入函数名
    def new_func(*args):
        # 运行装饰的代码
        start_time = datetime.now()
        func(*args)
        end_time = datetime.now()
        delta_time = end_time - start_time  # 计算程序执行时间
        print('花费时间%s' % delta_time)
    return new_func
```

下面定义几个函数测试一下：

```python
@run_time
def greet(name, word='Hello, '):		# 欢迎函数
    print(word + name)
greet('DrSHW', 'Hi, ')
'''
Hi, DrSHW
花费时间0:00:00
'''
@run_time
def add_to_n(n):  						# 求0 ~ n-1的和，循环n次
    res = 0
    for i in range(n):
        res += i
    print(res)
add_to_n(100000000)
'''
4999999950000000
花费时间0:00:03.202073
'''
```

## 主函数

我们先介绍`__name__`属性：

在每个python文件中，都包含内置的变量` __name__`:

+ 当该文件被**直接执行**的时候，`__name__ `等于文件名（包含后缀 .py  ）；

+ 如果该文件被导入`import`到**其他模块**中，则该模块的 __name__ 等于模块名称（不包含后缀.py ）
+ 而 **`__main__` 始终指当前执行模块的名称（包含后缀.py ）**。进而当模块被**直接执行**时，`__name__ == '__main__'` 结果为**真**。

（模块的导入在进阶篇的[**模块**](https://docs.drshw.tech/pb/senior/4/)一节会详细讲解，这里了解个大概就行 ）

可以直接执行`print(__name__)`进行验证。

所以，若我们想控制调用的函数与方法只有在文件被**直接执行**的时候才被执行，而被导入时不被执行，我们就可以使用：

```python
if __name__ == '__main__':
    代码体
```

进行判断，代码体就是所谓主函数的内容。
