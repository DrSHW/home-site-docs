---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

# 数值类型、布尔类型与运算

## 三种数值类型概述

分为整型(int)，浮点型(float)和复数类型(complex)，他们都是不可变类型。

+ 整型表示一个整数，且对位数不作限制，例如：

  ```python
  a = 1 	# a为整型
  b = 11111111111111111111111111111111111 	# b为整型
  ```

+ 浮点型表示一个小数，例如：

  ```python
  f1 = 3.14	# f1为浮点型
  ```

  其中，`round()`函数可以进行保留位数操作，格式为：`round(变量名, 保留多少位小数)`，例如：

  ```python
  f = 3.1415936
  x = round(f, 3)	# x的值为3.142
  ```

+ 复数类型表示一个复数，形式为`a+bj`，例如：

  ```python
  c1 = 1 - 2j	# c1为复数类型
  c2 = 1 + 1j	# c2为复数类型，j前的1必不可少
  c3 = 1.25 + 1.2j	# 实部与虚部均支持小数
  ```

## 布尔类型

有`True`和`False`两种取值，判断一个条件成立时，用`True`标识，不成立则用`False`标识。

所有数据类型都可以看作是一个布尔值，要么为`True`要么为`False`，规则如下：

1. `None`, `0`, `空字符串`，`空列表`，`空字典`, `空元组`六种情况下布尔值为`False`,
2. 其余均为`True`

+ 可通过`if`判断 （见**控制流程**一节 ） 或强制类型转换（`bool(变量名)` ）行验证，例如：

  ```python
  print(bool([]))	# False
  print(bool('DrSHW'))	# True
  ```

##  运算

### 数值运算

注意：若不加说明，三种数值类型均支持以下数值运算：

1. 加法运算 `+`	

   纯粹的加法，例如：

   ```python
   print(2 + 2)	# 4
   print(round(1.2 + (-1.3), 2)	# -0.1 支持括号运算，虽然是保留两位小数，但是Python会默认取去除最后的0
   print((1 + 2j) + (-5 + 4j))	# (-4+6j)
   ```

2. 减法运算 `-`

   纯粹的减法，例如：

   ```python
   print(3 - 2)	# 1
   ```

3. 乘法运算 `*`

   纯粹的乘法，例如：

   ```python
   print(9 * 9)	# 81
   print((1 + 2j) * (1 + 1j))	# (-1+3j)
   ```

4. 除法运算 `/`

   纯粹的除法，例如：

   ```python
   print(4 / 5)	# 0.8
   print(8 / 9)	# 0.8888888888888888 默认保留16位
   print((1 + 2j) / (1 + 1j))	# (1.5+0.5j)
   ```

5. 取余运算 `%`

   结果为两数整除后得到的**余数**，注意：复数类型不支持该运算，例如：

   ```python
   print(3 % 4)	# 3
   print(-3 % 4)	# 1 ，而不是3，搞不清楚可以看看取余的运算规则
   print(4.5 % 4.2)	# 0.7000000000000002	支持浮点型，存在可忽略的误差
   ```

6. 乘方运算 `**`

   `n ** m`代表 `n` 的 `m` 次幂，例如：

   ```python
   print(2 ** 3)	# 8
   print(4 ** 0.5)	# 2.0，小数次幂也支持，相当于开方运算
   print((-3+4j) ** 0.5)	# (1.0000000000000002+2j) 支持复数类型，存在可忽略的误差
   ```

7. 地板除运算 `//`

   也是除法，但是地板除运算要求结果**取整**，当运算数同号时进行**向下取整**，运算数异号时进行**向上取整**，

   当浮点数参与运算时，结果也是浮点数类型（尽管是整数 ），表现形式为`x.0`，

   注意：复数类型不支持该运算，例如：

   ```python
   print(10 // 6)	# 运算数同号，向下取整，无浮点数参与，故为整型结果1
   print(1.3 // -0.3)	# 运算数异号，向上取整，浮点数参与运算，故为浮点型-5.0
   print(-1.3 // -0.3)	# 运算数同号，向下取整，浮点数参与运算，故为浮点型4.0
   ```

### 赋值运算

1. 普通赋值 `=`

   将`=`右侧的值赋给左侧的变量。

   Python支持一次给多个变量进行赋值，例如：

   ```python
   a, b = 1, 2	# 同时给多个变量赋值
   print(a, b)	# 1 2
   a, b = b, a	# 也可以做到交换两个元素
   print(a, b)	
   ```

   

   这个操作已经很熟悉了，不作过多说明。

2. 运算赋值，分为加法赋值 `+= `, 减法赋值`-=`, 乘法赋值`*=`, 除法赋值`/=`, 取余赋值`%=` 乘方赋值`**=`, 地板除赋值`//=`，

   加法赋值： `n = n + X` 相等于 `n += X`，后面的运算赋值语法与其相似，例如：

   ```python
   n = 2
   n += 3	# 等价于 n = n + 3
   print(n)	# 5
   n -= 1    	# 等价于 n = n - 1
   print(n)	# 4
   n /= 2 	# 等价于 n = n / 1
   print(n)	# 2
   ```

   其余赋值运算同理。

### 比较运算

比较运算不仅适用于整数类型，也适用于其他的数值类型（如字符串，列表，字典 ）。

对于复数、列表、字典、元组的比较，这里只详细叙述等于运算的规则，其余比较运算几乎不会去使用。

比较运算指的是**值比较**，而不比较地址，甚至不比较类型，运算结果为一个布尔值。

1. 等于运算 `==`

   + 对于数值类型，即为两数值相等为 `True`，不相等为 `False`，例如：

     ```python
     print(2 == 3)	# False
     print(3.5 == 2.4)	# False
     print(2.0 == 2)	# True 值相等即为True，不考虑类型
     print(1 + 2j == 1 + 2j)	# True
     ```

   + 对于列表、元组和字符串类型，必须对应位置的对应元素相等才返回`True`，否则返回`False`，例如：

     ```python
     print([1, 2, 3] == [1, 2, 3]) 	# True
     print([1, 2, 3] == [1, 3, 2])	# False	
     print([1,2,3,4] == [1,2,3])	# False
     print((1, 2, 3) == (1, 2, 3)) 	# True
     print((1, 2, 3) == (1, 3, 2))	# False	
     print((1,2,3,4) == (1,2,3))	# False
     print('name' == 'name')	# True
     print('nmae' == 'name')	# False
     ```

   + 对于字典类型、集合类型，其中的元素个数和值完全相等即可返回`True`，不要求顺序，例如：

     ```python
     print({'name': 'John', 'age': 18} == {'age': 18, 'name': 'John'})	# True
     print({'code': 400, 'succcess': False} == {'code': 404, 'succcess': False})	# False
     print({1, 2, 3} == {1, 3, 2})	# True
     print({1, 2, 1} == {1, 2})	# True，集合自动去重
     print({1, 2, 3} == {1})	# False
     ```

2. 不等于运算 `!=`

   即为等于运算的反面，例如：

   ```python
   print(2 != 3)	# True
   ```

3. 内存比较`is`：

   若前后比较的两元素`id`值相等，返回`True`，否则返回`False`，`变量1 is 变量2`等价于`id(变量1) == id(变量2)`，例如：

   ```python
   a = 1
   b = 1
   c = 2
   print(a is b, b is c)	# True False
   ```

   对于不可变类型，效果和`==`运算符一致；对于可变类型，`is`运算不关心值是否相等，只关心**地址**是否相等。

4. 大于运算 `>`

   + 对于数值类型而言，前者大返回`True`，后者大返回`False`，例如:

     ```python
     print(2 > 3)	# False
     print(100.9 > 10.0)	# True
     # 支持连写，下面就省略
     print(30 > 20 > 10)	# True
     ```

   + 对于字符串类型，比较规则如下：

     + 从第一个字符开始，比较两串相应位置的字符，若两字符相等，则比较下一个字符
     + 若两字符不同，则比较两字符的编码（详见字符**编码与文件操作**一节 ），该字符编码大的所在字符串大
     + 若一个字符提前结束，前面的字符都相等，则长字符串大

     例如：

     ```python
     print("adc" > "abbbbbbbbbbb")	# True，第一个a相等，第二个d>b
     print("udc" > "uzbbbbbbbbbb")	# False一个u，第二个d<b
     print('LJJ yyds' > "LJJ")	# True，对应第三条规则
     ```

5. 小于运算`<`、大于等于运算`>=`、小于等于运算`<=` 

   了解比较规则后，这些运算符都很简单了。

   小于运算与大于运算相反，很好理解；

   大于等于即包含两种情况，若两数相等或大于运算成立，则为`True`，否则为`False`；

   小于等于和大于等于类似，例如：

   ```python
   print(2 < 3)	# True
   print("abc" < 'bcd')	# True
   print("abc" >= "abc")	# True
   print("acdc" >= "ymw")	# False
   print("abc" <= "abc")	# True
   print("acdc" <= "ymw")	# True
   ```


### 逻辑运算

逻辑运算是布尔值之间的运算。

虽是这么说，但由于所有类型的元素内部都隐含了一个布尔值，所以参与运算的变量不局限于布尔值。

1. `and` 与运算：

   若有两个变量(或表达式)`a`和`b`，当`a`和`b`都为真时，`a & b`才为真，否则为假，例如：

   ```python
   print(2 == 3 and 4 < 5)	# False，2 == 3为假，其中一个为假，表达式值为假
   print('r' in 'DrSHW' and {1, 2})	# True，前一个表达式为真，{1, 2}隐含布尔值为True
   ```

2.  `or` 或运算

   若有两个变量(或表达式)`a`和`b`，当`a`和`b`至少有一个真时，`a | b`就为真，`a`和`b`都为假时`a | b`才为假，例如：

   ```python
   print(2 == 3 or 4 < 5)	# True，2 == 3为假，4 < 5为真，有一个为真即表达式为真
   print('u' in 'DrSHW' and ())	# False，前一个表达式为假，()隐含布尔值为False
   ```

   以上两种运算具有**短路效应**：

   根据逻辑运算的特性：

   + 若一个合法表达式形如`x1 and x2 and ...`，从左至右看，若有一个表达式的值为`False`，则程序不会运行其右边的表达式，而直接返回`False`
   + 若一个合法表达式形如`x1 or x2 or ...`，从左至右看，若有一个表达式的值为`True`，则程序不会运行其右边的表达式，而直接返回`True`

   例如：

   ```python
   a = [1]
   print((2 == 3 and a.append(1)))	# False，2 == 3已经为假，系统不会执行右边的代码，直接返回False
   print(a)	# [1]
   print((3 == 3 and a.append(1)))	# True，3 == 3为真，a.append(1)返回[1, 1]隐含布尔值为True
   print(a)	# [1, 1]
   
   b = [2]
   print((3 >= 3 and b.append(2)))	# True，3 >= 3已经为真，系统不会执行右边的代码，直接返回True
   print(b)	# [2]
   print((1 >= 3 and b.append(2)))	# True，1 >= 3为假，b.append(2)返回[2, 2]隐含布尔值为True
   print(b)	# [2, 2]
   ```

3. `not` 非运算

   若有变量(或表达式)`a`，`not a`表示将`a`的逻辑取反，例如：

   ```python
   print(not 1 == 1)	# False，1 == 1原先为True，取反后为False
   print('a' not in 'DrSHW')	# Tru，1 == 1原先为True，取反后为False
   ```

若在一个逻辑表达式中同时出现这三种运算，`not`的优先级最高，系统会优先计算，即把紧跟其后的那个条件结果取反。

`or`和`and`的优先级一致，即会从左至右依次执行。
