---
description: 数据结构
layout: ../../../layouts/MainLayout.astro
---

## 1.2 算法和算法评价

### 1.2.1 算法的基本概念

算法（Algorithm）是**对特定问题求解步骤的一种描述**，它是指令的有限序列，其中的每条指令表示一个或多个操作。

<img src="https://images.drshw.tech/images/notes/image-20230227150459558.png" alt="image-20230227150459558" style="zoom:50%;" />

#### 算法的必备特性

1. **有穷性**：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。

   注：**算法**必须是**有穷**的，而**程序**可以是**无穷**的。

2. **确定性**：算法中每条指令必须有确切的含义，对于**相同的输入**只能得出**相同的输出**。

3. **可行性**：算法中描述的操作都可以通过已经实现的**基本运算执行有限次**来实现。

4. **输入**：一个算法**有零个或多个输入**，这些输入取自某个特定的对象的集合。

5. **输出**：一个算法**有一个或多个输出**，这些输出是与输入有着某种特定关系的量。

#### 算法的评价特性

1. **正确性**：算法应能正确地求解问题。
2. **可读性**：算法应具有良好的可读性，以帮助人们理解。
3. **健壮性**：输入非法数据时，算法能适当做出反应或进行处理，而不会产生莫名其妙的输出结果。
4. **高效率**和**低存储量需求**：即时间、空间复杂度低。

### 1.2.2 算法的时间复杂度

算法的时间复杂度`T(n)`表示**事前预估**算法**时间开销**`T`与**问题规模`n`**的关系。

<img src="https://images.drshw.tech/images/notes/image-20230227212044847.png" alt="image-20230227212044847" style="zoom:50%;" />

举个例子，求取前`n`个数之和的函数实现如下：

```c++
int sum(int n) {	// n 为问题规模
    int res = n;	// 存储最终结果
    while(n -- ) {	// 若n为0，终止循环
      res += n;
    }
    return res;
}
```

若传入值为`n`，则需要执行第2行1次，第3行`n + 1`次，第4行`n`次，第6行1次，总计`T(n) = 2n + 3`。

当算法变得复杂的情况下，一行一行数是不切实际的，由此我们也能将时间复杂度表达式简化处理。简化处理即仅考虑`n`非常大的时候，此时可只取表达式中**最高阶的项**，删去其余项（不是一个量级可忽略）：

![image-20230227201702051](https://images.drshw.tech/images/notes/image-20230227201702051.png)

同时，使用大O表示法，定义如下：`T(n) = O(f(n)) ⇔ lim(T(n) / f(n)) = k`。阶数对比：

![image-20230227203744139](https://images.drshw.tech/images/notes/image-20230227203744139.png)

此时可省略最高阶项前的常数，例如：

```
T1 = 2n + 3 = O(n)
T2 = n^3 + 2n^2 + 1000 = O(n^3)
T3 = nlogn + n + 105 = O(nlogn)
```

再举个例子，一个函数实现如下：

```c++
void test1(int n)
{
    int i = 1;
    while (i <= n)
    {
        cout << i << endl;
        i = i * 2;
    }
}
```

每次循环，`i`都将翻倍，当`2^i > n`，即`i > log2(n)`时，循环结束，即循环了`log2(n) + C`次（C为常数），时间复杂度为`O(log2(n))`。

对于类似于查找、排序算法，不同的输入数据会导致不一样的执行时间，例如最朴实的排序算法：

```c++
void find(int *a, int n, int x)
{
    int i;
    for (i = 0; i < n; i++)
    {
        if (a[i] == x)
        {
            cout << "find it" << endl;
            break;
        }
    }
    if (i == n)
    {
        cout << "not find" << endl;
    }
}
```

+ **最好**情况：元素`n`在第一个位置，此时对应**最好时间复杂度**`T(n) = O(1)`；
+ **最坏**情况：元素`n`在最后一个位置，此时对应**最坏时间复杂度**`T(n) = O(n)`；
+ **平均**情况：假设元素`n`在任意一个位置的概率相同为`1/n`，此时对应**平均时间复杂度**`T(n) = O(n)`；

一般只考虑最坏和平均时间复杂度。

### 1.2.3 算法的空间复杂度

算法的空间复杂度`S(n)`表算法**空间（内存）开销**`S`与**问题规模`n`**的关系。

![image-20230227230532912](https://images.drshw.tech/images/notes/image-20230227230532912.png)

看几种情况：

**例一** 若无论问题规模如何变化，算法运行所需的内存空间都是固定的常量：

```c++
int sum(int n) {	// n 为问题规模
    int res = n;	// 存储最终结果
    while(n -- ) {	// 若n为0，终止循环
      res += n;
    }
    return res;
}
```

算法所需内存空间为常量，算法空间复杂度为：`S(n) = O(1)`，也称算法**原地工作**。

**例二** 算法所需内存空间与问题规模`n`有关：

```c++
int fib(int n)
{
  if (n == 1 || n == 2)
  {
    return 1;
  }
  int flag[n];
  flag[0] = 1;
  flag[1] = 1;
  for (int i = 2; i < n; i++)
  {
    flag[i] = flag[i - 1] + flag[i - 2];
  }
  return flag[n - 1];
}
```

假设一个`int`类型的变量占4B，则所需内存空间`S = 4(形参n) + 4n(数组) = 4n + 4 = O(n)`

多维数组的情况这里就不举例了。

**例三** 函数递归调用带来的内存开销，以最简单的递归求斐波那契数列为例：

```c++
int fib(int n)
{
  if (n == 1 || n == 2)
  {
    return 1;
  }
  return fib2(n - 1) + fib2(n - 2);
}
```

以传入参数`5`为例，我们需要关注其调用次序：

<img src="https://images.drshw.tech/images/notes/image-20230227224643555.png" alt="image-20230227224643555" style="zoom:50%;" />

其调用栈占用最多时状态如下：

<img src="https://images.drshw.tech/images/notes/image-20230227225213289.png" alt="image-20230227225213289" style="zoom:50%;" />

可见，当`n`大于4时，每当`n`变大1，调用栈中最大元素个数将加2，因此`S(n) = 2n + C = O(n)`。

若递归过程中还需要再多声明一个数组：

```c++
int fib(int n)
{
  int useless[n];
  if (n == 1 || n == 2)
  {
    return 1;
  }
  return fib2(n - 1) + fib2(n - 2);
}
```

此时`S(n) = (2n + 2) + (2(n - 1) + 2) + ... + 2 + C = O(n^2)`。

