---
description: Docs intro
layout: ../../layouts/MainLayout.astro
---

## 8.2 内部排序算法及性能对比

排序，即将一系列杂乱排布的元素，按照一定的优先级（可以是大小、偏移量），变成有序序列的过程。

排序算法有下面几种：

<img src="https://images.drshw.tech/images/notes/1130_0ce35b527a-1.png" alt="1130_0ce35b527a-1" style="zoom:50%;" />

其中排序的稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，`A1=A2`，且`A1`在`A2`之前，而在排序后的序列中，`A1`仍在`A2`之前，则称这种排序算法是稳定的；否则称为不稳定的。

这里先讲最为常用的两种排序思路——**快速排序**与**归并排序**，之后的几种算法很少使用，欣赏下思路即可。

以解决下面的问题为例：

> 给定你一个长度为 `n` 的整数数列，请你使用快速排序对这个数列按照**从小到大**进行排序，并将排好序的数列按顺序输出。
>
> #### 输入格式
>
> 输入共两行，第一行包含整数 `n`。
>
> 第二行包含 `n` 个整数，表示整个数列。
>
> #### 输出格式
>
> 输出共一行，包含 `n` 个整数，表示排好序的数列。

可视化排序过程：[网址](https://daweedkob.github.io/sorting_algos/)。

### 快速排序

算法流程：

对于数组`q`，长度为`n`，若对于其中的一段（最左索引`l`，最右索引`r`，这里表示为`[l, r]`）进行排序：

1. 定义左右指针`i`、`j`，分别指向`l`、`r`对应的索引位置；指定`x`为划分界限（默认取`(l + r)/2`索引对应的数组值）；
2. 使用左右指针`i`、`j`遍历`[l, r]`，需要保证`q[i] <= x && q[j] >= x`；`i`指针不断右移（`i ++`），遇到`q[i] > x`则停止，同理`j`指针不断左移（`j --`），遇到`q[j] < x`则停止；
3. 若`i < j`（两指针指向的区域没有交叉，即未遍历完毕），则交换`q[i]`与`q[j]`，并重复步骤2；否则执行下一步；
4. 经过操作后，`[l, r]`将被分为两部分——前一部分的值均小于`x`，而后一部分的值均大于`x`；`i`指向了后一部分的起始位置，而`j`指向了前一部分的终止位置，故两部分可以表示为`[l, j]`与`[j + 1, r]`；此时再次按同样的规则（步骤1~3），对这两部分递归处理，若左右边界重合则递归结束，即可得到排序后的数组。

完整代码：

```cpp
#include <iostream>

using namespace std;

const int N = 1e5 + 10;
int q[N];

void quick_sort(int q[], int l, int r)
{             // 传入数组与左右边界
  if (l >= r) // 终止条件
    return;
  int i = l - 1, j = r + 1; // 定义指针i, j（需要中和do ... while中先执行的自增、自减运算）
  int x = q[l + r >> 1];    // 指定x为划分界限
  while (i < j)
  {
    do
      i++;
    while (q[i] < x);       // 从左往右找到第一个大于等于x的数
    do
      j--;
    while (q[j] > x);       // 从右往左找到第一个小于等于x的数
    if (i < j)
      swap(q[i], q[j]);     // 交换两个数
  }
  quick_sort(q, l, j);      // 对左半部分[l, j]递归
  quick_sort(q, j + 1, r);  // 对右半部分[j + 1, r]递归调用
}

int main(){
  cin >> n;
  for (int i = 0; i < n; i ++)
    cin >> q[i];
  quick_sort(q, 0, n - 1);
  for (int i = 0; i < n; i ++)
    cout << q[i] << ' ';
  cout << endl;
  return 0;
}
```

### 归并排序

算法总体分为两步：

1. 递归地将原数组`q`分为多个**只有一个元素**的数组；
2. 将相邻的两个有序数组（只有单个元素数组也是有序的）合并为一个有序数组`tmp`；
3. 再将`tmp`中的各段内容写回`q`。

图解：

![img](https://s3.bmp.ovh/imgs/2022/09/18/ae8e30974e7cb052.gif)

完整代码及注释：

```cpp
#include <iostream>

using namespace std;

const int N = 1e3 + 10;
int q[N], tmp[N];

void merge_sort(int q[], int l, int r)
{
  if (l >= r) // 直到l==r，说明只有一个元素，不用再分了
    return;
  int mid = l + r >> 1;          // 每次都是从中间分开，分成左右两块
  merge_sort(q, l, mid);         // 左边再分
  merge_sort(q, mid + 1, r);     // 右边再分
  int i = l, j = mid + 1, k = 0; // i为左半边起始位置，j为右半边起始位置，k为左右两边合并后数组的元素个数
  // 将左右两个数组合并至tmp数组，由于整个过程子数组都是有序的，只需要比较左右两个数组的第一个元素，将较小的放入tmp数组即可
  while (i <= mid && j <= r)
  {
    if (q[i] < q[j])
      tmp[k++] = q[i++];
    else
      tmp[k++] = q[j++];
  }
  while (i <= mid) // 将左边剩余的元素填充进tmp中
    tmp[k++] = q[i++];
  while (j <= r) // 将右边剩余的元素填充进tmp中
    tmp[k++] = q[j++];

  for (int i = l, k = 0; i <= r; i++, k++)  // 将tmp数组中的元素全部拷贝到原数组中
    q[i] = tmp[k];
}

int main()
{
  int n;
  cin >> n;
  for (int i = 0; i < n; i++)
    cin >> q[i];
  merge_sort(q, 0, n - 1);
  for (int i = 0; i < n; i++)
    cout << q[i] << " ";
  return 0;
}
```

### 选择排序

最无脑的排序方式，也是最低效的排序方式，基本思想：遍历数组`q`，每次找到遍历位置之后的最小的元素，放在数组的最前面：

算法主体代码及注释：

```cpp
// 选择排序：遍历数组，每次找到遍历位置之后的最小的元素，放在数组的最前面
void select_sort(int q[], int n)
{
  for (int i = 0; i < n; i++)
  {
    int t = i;  // t为当前最小值的下标
    for (int j = i + 1; j < n; j++)   // 从i+1开始找最小值
      if (q[j] < q[t])    // 找到最小值
        t = j;            // 更新最小值的下标
    swap(q[i], q[t]);     // 将最小值放在前面
  }
}
```

### 冒泡排序

大多数新人入门时接触到的第一个算法，流程如下：

遍历`n-1`次原数组`q`；每一次遍历时，若发现当前元素比后一个元素大，则交换两个元素的位置；最后将得到一个有序序列。

算法主体代码及注释：

```cpp
void bubble_sort(int q[], int n)
{
  for (int i = 0; i < n - 1; i++)   // n-1趟
    for (int j = 0; j < n - 1 - i; j++) // 因为每一趟都会把最大的数放到最后，所以不用再比较了，所以遍历n-1-i次
      if (q[j] > q[j + 1])      // 如果前面的数比后面的数大，就交换
        swap(q[j], q[j + 1]);
}
```

### 插入排序

算法流程类似于抓扑克牌，遍历数组`q`；每遍历一个位置`i`处的元素`t`，则从`i`处往前找到第一个比`t`小的值，并把`t`插入该值的后面；最后将得到一个有序序列。

算法主体代码及注释：

```cpp
void insert_sort(int q[], int n)
{
  for (int i = 1; i < n; i++)
  {
    int j = i - 1, t = q[i];  // t为待插入的数
    while (j >= 0 && q[j] > t)  // 从后往前找到第一个比t小的数
    {
      q[j + 1] = q[j];  // 将这个数后移
      j--;
    }
    q[j + 1] = t;   // 将t插入到这个数的后面
  }
}
```

### 希尔排序

算是插入排序的改进版本：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；

基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。

算法步骤：将数组分成`gap`个子数组，对每个子数组进行插入排序，然后缩小`gap`，重复上述过程，直到`gap == 1`。

算法主体代码及注释：

```cpp
void shell_sort(int q[], int n)
{
  for (int gap = n / 2; gap; gap /= 2) // gap为步长，每次减半
    for (int i = gap; i < n; i++)      // 从第gap个元素开始，逐个对其所在组进行直接插入排序操作
      for (int j = i - gap; j >= 0 && q[j] > q[j + gap]; j -= gap)  // 从第i个元素开始，逐个对其所在组进行直接插入排序操作
        swap(q[j], q[j + gap]);
}
```



