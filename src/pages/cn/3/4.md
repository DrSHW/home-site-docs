---
description: 计算机网络
layout: ../../../layouts/MainLayout.astro
---

## 3.4 流量控制与可靠传输机制

### 3.4.1 流量控制的基本概念

一些概念：

+ 可靠传输：实现接收端接受的数据与发送端发送的 **同步且无差错** 。
+ 流量控制：实现对 **发送速率的控制** ，减少传输出错与资源浪费，使接收方有足够的缓冲时间来接收每一个帧。

**较快的发送速度**和**较低的接受能力**的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。

**数据链路层**的流量控制是点对点（相邻结点间）的，而**传输层**的流量控制是端到端（主机与主机间）的。

**数据链路层**的流量控制手段：接收方收不下就不回复确认。

**传输层**的流量控制手段：接收端给发送端一个窗口公告。

### 3.4.2 流量控制的方法

有以下几种流量控制的方法：

1. 停止-等待协议：

   **1）为什么要有停止-等待协议？**

   ① 除了比特出差错，底层信道还会出现_丢包_问题。

   > 丢包：物理线路故障，设备故障、病毒攻击、路由信息错误等原因，会导致数据包的丢失。

   ② 为了实现流量控制。

   **2）研究停等协议的前提？**

   ① 虽然现在常用全双工通信方式，但为了讨论问题方便，仅考虑一方发送数据（发送方），以防接收数据（接收方）。

   ② 因为是在讨论可靠传输的原理，所以并不考虑数据是哪一层次上传送的。

   **3）原理与实现步骤？**

   每发送完一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧。

   + 发送窗口：发送方维持一组连续是允许发送的帧的序号。

   + 接收窗口：接收方维持一组连续的允许接收帧的序号。

   在数据链路层中，发送窗口与接收窗口的大小为 **固定值** 。

   发送窗口大小=1，接收窗口大小=1。

   ① 无差错情况下：

   ![image-20221231214540590](https://images.drshw.tech/images/notes/image-20221231214540590.png)

   ② 有差错情况下：

   ​	**I． 数据帧丢失或检测到出错**

   ![image-20221231214604595](https://images.drshw.tech/images/notes/image-20221231214604595.png)

   ​	注意：

   + 每发完一个帧，必须保留它的副本。
   + 数据帧和确认帧必须编号。

   ​	**II． 确认帧ACK丢失**

   ![image-20221231214641442](https://images.drshw.tech/images/notes/image-20221231214641442.png)

   ​	**III． 确认帧ACK迟到**

   ![image-20221231214656589](https://images.drshw.tech/images/notes/image-20221231214656589.png)

   **4) 性能？**

   优点：简单易实现。

   缺点：信道利用率太低，大部分时间数据都在路上，发送方很长时间闲置，资源浪费。（流水线技术）

   ![image-20221231214819386](https://images.drshw.tech/images/notes/image-20221231214819386.png)

   此情况下信道利用率：

   <img src="https://images.drshw.tech/images/notes/image-20221231214853170.png" alt="image-20221231214853170" style="zoom:67%;" />

   例题：一个信道的数据传输率为4kb/s，单向传播时延为30ms，如果使停止-等待协议信道最大利用率达到80%，要求的数据帧长度至少为（）。

   解：

   <img src="https://images.drshw.tech/images/notes/image-20221231214943357.png" alt="image-20221231214943357" style="zoom: 67%;" />

   **停等协议总结：**

   ![image-20221231215013705](https://images.drshw.tech/images/notes/image-20221231215013705.png)

2.  <img src="https://images.drshw.tech/images/notes/image-20221231215052752.png" alt="image-20221231215052752" style="zoom:50%;" />

   对停等协议的改进：

   1. 增加了序号范围;
   2. 发送方需要缓存多个分组。

   两种方案的对比：

   + **GBN：发送窗口大小\>1，接收窗口大小=1。**
   + **SR：发送窗口大小\>1，接收窗口大小\>1。**

   <img src="C:/Users/17100/AppData/Roaming/Typora/typora-user-images/image-20221231215136890.png" alt="image-20221231215136890" style="zoom: 67%;" />

   **1）GBN协议：**

   **大致流程：**

   ![image-20221231215316999](https://images.drshw.tech/images/notes/image-20221231215316999.png)

   **GBN发送方必须相应的三件事：**

   1. **上层的调用**

      上层要发送数据时，发送方先检查发送窗口是否已满，如果 **未满** ，则产生一个帧并将其发送；如果 **窗口已满** ，发送方只需将数据返回给上层，按时上层窗口已满。上层等一会再发送。（实际实现中，发送方可以缓存这些数据，窗口不满时再发送帧）

   2. **收到了一个ACK确认帧**

      GBN协议中，对n号帧的确认采用**累计确认**的方式，标明接收方已经收到n号帧和它之前的全部帧。

      > 累计确认：就是收到一个确认帧，那么 **它和它之前的所有帧** 都默认已收到，反之，如果某个确认帧没收到，那么 **它和它之后的所有帧** 都默认丢失（即使收到了也丢掉），进行重传。

   3. **超时事件**

      协议的名字为后退N帧/回退N帧，来源于出现丢失和时延过长帧时发送方的行为。就像再停等协议中一样，定时器将再次用于恢复数据帧或确认帧的丢失。如果出现超时，发送方重传所有已发送但违背确认的帧。

   **GBN接收方要做的事：**

   1. 如果正确收到`n`号帧，并且按序，那么接收方为`n`帧发送一个ACK，并将该帧中的数据部分交付给上层。
   2. 其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK。接收方无需缓存任何失序帧，只需要维护一个信息：`expectedseqnum`（下一个按序接收的帧序号）。

   **GBN的整体运作流程：**

   假设发送窗口尺寸为4，

   ![image-20221231215532574](https://images.drshw.tech/images/notes/image-20221231215532574.png)

   可见，若出现超时，发送方将重传所有已发送但未被确认的帧。

   **窗口的宽度限制：**

   若采用n个比特对帧编号，那么发送窗口的尺寸 <img src="https://images.drshw.tech/images/notes/image-20221231224616205.png" alt="image-20221231224616205" style="zoom:45%;" /> 应满足：<img src="https://images.drshw.tech/images/notes/image-20221231224637693.png" alt="image-20221231224637693" style="zoom:45%;" />。因为发送窗口尺寸过大，就会使得接收方无法区别新帧和旧帧。

   **GBN协议的重点总结：**

   1. 累积确认（偶尔捎带确认）
   1. 接收方只按序接收帧，不按序则丢弃
   1. 确认序列号最大的、按序到达的帧
   1. 发送窗口最大为 <img src="https://images.drshw.tech/images/notes/image-20221231224721175.png" alt="image-20221231224721175" style="zoom:50%;" />，接收窗口大小为1
   
   
   
   例题：
   
   ![image-20221231224741977](https://images.drshw.tech/images/notes/image-20221231224741977.png)
   
   **GBN协议的性能：**
   
   1. 优点：因连续发送数据帧而提高了信道利用率。
   1. 缺点：在重传时必须把原来已经正确的数据帧重传，使传输效率降低。（由选择重传协议弥补）
   
   **GBN总结：**
   
   ![image-20221231224811067](https://images.drshw.tech/images/notes/image-20221231224811067.png)
   
   **2）SR协议：**
   
   为了改进GBN中批量重传的问题而设计。
   
   解决方法：设置单个确认，同时加大接收窗口，设置接收缓存，缓存乱序到达的帧。
   
   **SR协议大致流程：**
   
   ![image-20221231224846266](https://images.drshw.tech/images/notes/image-20221231224846266.png)
   
   **SR协议发送方必须做的三件事：**
   
   1. **上层的调用**
   
      从上层收到数据后，SR发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧；否则就像GBN一样，要么将数据 **缓存** ，要么 **返回给上层** 之后再传输。
   
   2. **收到了一个ACK**
   
      如果收到ACK，加入该帧序号在窗口内，则SR发送方将那个被确认的帧标记为已接收。如果该帧序号是窗口的下界（最左边第一个窗口对应的序号），则窗口向前移动到具有最小序号的未确认帧处。如果窗口移动了并且有序号在窗口内的未发送帧，则发送这些帧。
   
   3. **超时事件**
   
      每个帧都有一个自己的定时器，一个超时事件发生后 **只重传一个帧** 。
   
   **SR协议接收方要做的事：**
   
   + **来者不拒（窗口内的帧）**
   
     SR接收方将 **确认一个正确接收的帧** 而不管其是否按序。
   
     失序的帧将被 **缓存** ，并返回给发送方一个该帧的确认帧 **【收谁确认谁】** ，直到所有帧（即序号更小的帧）皆被收到为止，这时才可以将一批帧按序交付给上层，然后 **向前移动滑动窗口** 。
   
     如果收到了窗口序号外的帧，就返回一个ACK，其他情况直接丢弃。
   
   **SR的整体运作流程：**
   
   假设发送窗口和接收窗口的尺寸均为4，
   
   ![image-20221231225039347](https://images.drshw.tech/images/notes/image-20221231225039347.png)
   
   **窗口的宽度限制：**
   
   发送窗口最好等于接收窗口。（大了会溢出，小了没意义）
   
   <img src="https://images.drshw.tech/images/notes/image-20221231225107072.png" alt="image-20221231225107072" style="zoom:50%;" />
   
   **SR协议重点总结：**
   
   1. 对数据帧逐一确认，收一个确认一个、
   1. 只重传出错的帧
   1. 接收方有缓存
   1.  <img src="https://images.drshw.tech/images/notes/image-20221231225203336.png" alt="image-20221231225203336" style="zoom:50%;" />
   

例题：

![image-20221231225216633](https://images.drshw.tech/images/notes/image-20221231225216633.png)

**SR协议总结：**

![image-20221231225224354](https://images.drshw.tech/images/notes/image-20221231225224354.png)

### 3.4.3 本节小结

![image-20221231225253308](https://images.drshw.tech/images/notes/image-20221231225253308.png)
