---
description: 组成原理
layout: ../../../layouts/MainLayout.astro
---

## 2.3 浮点数的表示和运算

### 2.3.1 浮点数的表示

<img src="https://images.drshw.tech/images/notes/image-20230311201042342.png" alt="image-20230311201042342" style="zoom:50%;" />

#### 从定点数到浮点数

由于定点数可表示的范围有限，但我们不能无限制地增加数据的长度，由此引入了浮点数的概念。

类似于科学计数法，`+302657264526 = +3.026*10^11`，也可记作`+11 +3026`，前一个数表示**阶码**，后一个数表示**尾数**：

<img src="https://images.drshw.tech/images/notes/image-20230311191522226.png" alt="image-20230311191522226" style="zoom: 50%;" />

+ 阶码可记为`E`，反映浮点数的**表示范围**及**小数点的实际位置**；
+ 尾数可记为`M`，数值部分的位数`n`反映浮点数的**精度**；
+ 尾数给出了一个小数，阶码指明了小数点要向前/向后移动几位。

浮点数的真值可记为<img src="https://images.drshw.tech/images/notes/image-20230311192303055.png" alt="image-20230311192303055" style="zoom:50%;" />（`r`表示阶码的底数，即`r`进制）。

在计算机中，也遵循这样的表示原则，一般：

+ 阶码`E`使用**补码或移码**表示的定点整数；
+ 尾数`M`常用**原码或补码**表示的定点小数。

> 例：若阶码、尾数均用补码表示，`a = 0,01; 1.1001`，`b = 0,10; 0.01001`，求`a`、`b`的真值。
>
> + 对于`a`：
>
>   + 阶码`0,01`对应真值`+1`；
>   + 尾数`1.1001`对应真值`-0.0111 = -(2^-2 + 2^-3 + 2^-4)`；
>
>   因此，`a`的真值为`2^1 * (-0.0111) = -0.111`。
>
>   （可以看出，阶码相当于将尾数表示的定点小数**算数左移了一位**，或**小数点右移了一位**）
>
> + 对于`b`：
>
>   + 阶码`0,10`对应真值`+2`；
>   + 尾数`0.01001`对应真值`+0.01001 = +(2^-2 + 2^-5)`；
>
>   因此，`b`的真值为`2^2 * (+0.01001) = +1.001`。
>
>   （对`b`而言，若采用1B的存储空间，将会损失一位精度，若`b`的存储改为`0,01; 0.1001`，就不会损失精度。由此引入了浮点数**规格化**的概念）

#### 浮点数尾数的规格化

规格化浮点数即：规定**尾数的最高数值位必须是一个有效值（非0）**。

两种规格化方式： 

+ **左规**：当浮点数运算的结果为非规格化时，要进行规格化处理，即将**尾数算数左移一位，阶码减1**；
+ **右规**：当浮点数运算的结果尾数出现溢出（双符号位为01或10时），即将**尾数算数右移一位，阶码加1**；

<img src="https://images.drshw.tech/images/notes/image-20230311195135758.png" alt="image-20230311195135758" style="zoom:50%;" />

注：采用“双符号位”，当溢出发生时，可以挽救。更高的符号位是正确的符号位。

#### 规格化浮点数的特点

##### 用原码表示的尾数进行规格化：

正数为`0.1xx...x`的形式，

+ 其最大值表示为`0.11...1`；
+ 最小值表示为`0.10...0`；
+ 尾数`M`的表示范围为`1/2 ≤ M ≤ (1 - 2^-n)`。

负数为`1.1xx...x`的形式，

+ 其最大值表示为`1.10...0`；
+ 最小值表示为`1.11...1`；
+ 尾数`M`的表示范围为`-(1 - 2^-n) ≤ M ≤ -1/2`。

##### 用补码表示的尾数进行规格化：

正数为`0.1xx...x`的形式，同原码表示。

负数为`1.0xx...x`的形式，

+ 其最大值表示为`1.01...1`；
+ 最小值表示为`1.00...0`；
+ 尾数`M`的表示范围为`-1 ≤ M ≤ -(1/2 + 2^-n)`。

#### 【大纲已删】浮点数的上溢、下溢

若要表示的数超出了机器浮点数的最高精度（尾数超过了机器表示范围），称此情况为下溢，正数发生下溢被称为正下溢，负数则为负下溢；会将丢失的精度当作机器0处理。

若要表示的数阶码超出了机器表示范围，称此情况为上溢，正数发生上溢被称为正上溢，负数则为负上溢；通常系统将抛出异常。

<img src="https://images.drshw.tech/images/notes/image-20230311200825687.png" alt="image-20230311200825687" style="zoom:50%;" />

### 2.3.2 IEEE 754标准

为了便于数据的迁移，需要一个统一浮点数在计算机内表示的标准，于是出现了IEEE 754标准。

在[2.1](https://docs.drshw.tech/co/2/1/#216-%E7%A7%BB%E7%A0%81)中我们曾提到移码的概念，当时的偏置值取`2^(n-1)`（`n`位二进制移码），但在IEEE 754标准下，偏置值取`2^(n-1) - 1`：

<img src="https://images.drshw.tech/images/notes/image-20230311202134541.png" alt="image-20230311202134541" style="zoom:50%;" />

IEEE 754标准规定的浮点数表示方法如下：

<img src="https://images.drshw.tech/images/notes/image-20230311202532587.png" alt="image-20230311202532587" style="zoom:50%;" />

（阶码全0、全1均需作为特殊用途）

长短浮点数与其真值的计算方式：

<img src="https://images.drshw.tech/images/notes/image-20230311202702136.png" alt="image-20230311202702136" style="zoom:50%;" />

注意：<img src="https://images.drshw.tech/images/notes/image-20230311204045133.png" alt="image-20230311204045133" style="zoom:50%;" />。

十进制数转单精度浮点数举例：

<img src="https://images.drshw.tech/images/notes/image-20230311202903714.png" alt="image-20230311202903714" style="zoom:50%;" />

单精度浮点数转十进制数举例：

<img src="https://images.drshw.tech/images/notes/image-20230311203013715.png" alt="image-20230311203013715" style="zoom:50%;" />

由浮点数确定真值（阶码不是全0、也不是全1）方法总结：

1. 根据“某浮点数”确定数符、阶码、尾数的分布；
2. 确定尾数`1.M`（注意补充到最高位的隐含位1）；
3. 确定阶码的真值 = 移码 - 偏置值；
4. 真值 = <img src="https://images.drshw.tech/images/notes/image-20230311205036802.png" alt="image-20230311205036802" style="zoom:50%;" />。

单精度浮点型能表示的最小绝对值、最大绝对值：

+ 最小绝对值：尾数全为0，阶码真值最小-126，对应移码机器数`0000 0001`，此时整体的真值为<img src="https://images.drshw.tech/images/notes/image-20230311203237919.png" alt="image-20230311203237919" style="zoom:50%;" />；
+ 最大绝对值：尾数全为1，阶码真值最大127，对应移码机器数`1111 1110`，此时整体的真值为<img src="https://images.drshw.tech/images/notes/image-20230311203341690.png" alt="image-20230311203341690" style="zoom:50%;" />；

<img src="https://images.drshw.tech/images/notes/image-20230311203424599.png" alt="image-20230311203424599" style="zoom:50%;" />

若要表示的数的**超出了规格化数的表示范围**，则需要使用**阶码全0/1**的状态：

+ 当**阶码`E`全为0，尾数`M`不全为0**时，表示**非规格化小数**<img src="https://images.drshw.tech/images/notes/image-20230311203910891.png" alt="image-20230311203910891" style="zoom:50%;" />（隐含最高位变为0，阶码真值固定视为-126）；
+ 当**阶码`E`全为0，尾数`M`也为0**时，表示**真值 ±0**；
+ 当**阶码全为1，尾数M全为0**时，表示**无穷大 ± ∞**；
+ 当**阶码全为1，尾数M不全为0**时，表示**非数制 “NAN”**，一般表示非法运算（0/0 或 ∞-∞）产生的结果。

### 2.3.3 浮点数的运算

<img src="https://images.drshw.tech/images/notes/image-20230311222203784.png" alt="image-20230311222203784" style="zoom:50%;" />

#### 浮点数的加减运算

例：已知十进制数`X = -5/256`、`Y = +59/1024`，按机器补码浮点运算规则计算`X - Y`，结果用二进制表示，浮点数格式如下：阶符取2位，阶码取3位，数符取2位，尾数取9位。补码和尾数均使用补码表示。

运算步骤：

1. 将真值转换为二进制数；

   <img src="../../../../../../AppData/Roaming/Typora/typora-user-images/image-20230311214811268.png" alt="image-20230311214811268" style="zoom:50%;" />

2. 对阶：将两运算数的阶码相等，小阶向大阶看齐；尾数每右移一位，阶码加1；

   <img src="../../../../../../AppData/Roaming/Typora/typora-user-images/image-20230311214936115.png" alt="image-20230311214936115" style="zoom:50%;" />

3. 尾数加减：

   <img src="../../../../../../AppData/Roaming/Typora/typora-user-images/image-20230311215208037.png" alt="image-20230311215208037" style="zoom:50%;" />

   尾数符号位为10，发生了溢出。

4. 规格化：

   由于尾数发生了溢出，故采用右规：

   <img src="https://images.drshw.tech/images/notes/image-20230311215426547.png" alt="image-20230311215426547" style="zoom:50%;" />

5. 舍入：

   一般有两种舍入的方法：

   + **“0”舍“1”入法**：

     类似于十进制数运算中的“四舍五入”法，即在尾数右移时，被移去的最高数值位为0，则舍去:被移去的最高数值位为1,则在尾数的末位加1。这样做可能会使尾数又溢出，此时需再做一次右规。

   + **恒置“1”法**：

     尾数右移时，不论丢的最高数值位是“1”还是“0”都使右移后的尾数末位恒置“1”。这种方法同样有使尾数变大和变小的两种可能。

   若采用“0”舍“1”入法，由于此处舍弃的最低位为0，故无舍入。

6. 判溢出：

   <img src="https://images.drshw.tech/images/notes/image-20230311215542201.png" alt="image-20230311215542201" style="zoom: 50%;" />

#### 强制类型转换

以C语言为例，各个数据类型的位长如下：

<img src="https://images.drshw.tech/images/notes/image-20230311220737209.png" alt="image-20230311220737209" style="zoom:50%;" />

其中：

```
char -> int -> long -> double
float -> double
```

这些数据类型在转换时，范围、精度从小到大，转换过程没有损失。

而：

```
int -> float
```

对于32位机器：

+ `int`：表示整数，范围`-231~ 231-1`，有效数字32位；
+ `float`：表示整数及小数，范围士`[2^-126 ~ 2^127 * (2-2^-23)]`，有效数字`23 + 1 = 24`位。

有效数字位数不同，因此该转换可能损失精度；

```
float -> int
```

该转换可能溢出及损失精度。

