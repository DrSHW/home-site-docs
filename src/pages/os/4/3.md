---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 4.3 基本分页存储管理方式

### 4.3.1 非连续分配方式介绍

#### 非连续分配方式的引入

前面讲的连续分配方式有如下的缺点：

1. 对于固定分区分配方式：缺乏灵活性，会产生大量的内部碎片，内存的利用率很低；

   <img src="https://images.drshw.tech/images/notes/image-20221021231728155.png" alt="image-20221021231728155" style="zoom:50%;" />

2. 对于动态分区分配方式：会产生很多外部碎片，虽然可以用“紧凑”技术来处理，但是“紧凑”的时间代价很高。

<img src="https://images.drshw.tech/images/notes/image-20221021231740432.png" alt="image-20221021231740432" style="zoom:50%;" />

如果允许将一个进程分散地装入到许多不相邻的分区中，便可充分地利用内存，而无需再进行“紧凑”。

基于这一思想，产生了**非连续分配方式**，或者称为“离散分配方式”，即为用户进程分配的可以是一些**分散的内存空间**。

非连续分配方式可分为三种类型：

<img src="https://images.drshw.tech/images/notes/image-20221021234555360.png" alt="image-20221021234555360" style="zoom:50%;" />

#### 非连续分配的基本思路

假设有一个大小为23MB的进程A，若按固定分区分配算法，每个分区大小只有10MB，显然是放不下的。

若采用非连续分配的方式，若允许进程占用多个分区，那么可以**把进程拆分成 `10MB + 10MB + 3MB` 三个部分**，再把这三个部分分别放到三个分区中（这些**分区不要求连续**）：

<img src="https://images.drshw.tech/images/notes/image-20221021234758186.png" alt="image-20221021234758186" style="zoom:50%;" />→<img src="https://images.drshw.tech/images/notes/image-20221021235248612.png" alt="image-20221021235248612" style="zoom:50%;" />

进程A的最后一个部分是3MB，放入分区后会产生7MB的**内部碎片**。

若每个分区大小为2MB，那么进程A可以拆分成`11 * 2MB + 1MB`共12个部分，只有最后一部分1MB占不满分区，会产生1MB的内部碎片。

显然，**如果把分区大小设置的更小一些，内部碎片会更小，内存利用率会更高**。

基本分页存储管理的思想：把内存分为一个个相等的**小分区**，再按照分区大小将进程拆分成一个个小部分。

### 4.3.2 分页存储管理的基本概念

<img src="https://images.drshw.tech/images/notes/image-20221022172821316.png" alt="image-20221022172821316" style="zoom:50%;" />

#### 基本概念

将内存空间分为一个个**大小相等的分区**（比如：每个分区4KB），每个分区就是一个“**页框**”，或称“**页帧**”、“**内存块**”、“**物理块**”。每个页框有一个编号，即“**页框号**”（或者“**内存块号**”、“**页帧号**”、“**物理块号**”）。页框号***从0开始***。

将用户进程的地址空间也分为***与页框大小相等***的一个个区域，称为“**页**”或“**页面**”。每个页面也有一个编号，即“页号”，页号也是***从0开始***。

（注：进程的最后一个页面可能没有一个页框那么大。因此，**页框不能太大，否则可能产生过大的内部碎片**）

操作系统**以页框为单位为各个进程分配**内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的**页面**与内存的**页框**有**一一对应**的关系：

<img src="https://images.drshw.tech/images/notes/image-20221022164331896.png" alt="image-20221022164331896" style="zoom:50%;" />→ <img src="https://images.drshw.tech/images/notes/image-20221022164408777.png" alt="image-20221022164408777" style="zoom:50%;" />

各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。

#### 地址变换过程

将进程地址分页后，操作系统需要实现逻辑地址到物理地址的转换。

类似[动态重定位的装入方式](https://docs.drshw.tech/os/4/1/#%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D)，采用分页技术后，一个进程的逻辑地址会被分为一个个页面，各个页面会被离散地装入内存中：

<img src="https://images.drshw.tech/images/notes/image-20221022165158024.png" alt="image-20221022165158024" style="zoom:50%;" />

要将需要访问的逻辑地址转换为物理地址，要经历如下四个步骤：

1. 要算出逻辑地址对应的**页号**；

   **页号** = 逻辑地址 / 页面长度（**取整**）

2. 要知道该页号对应**页面在内存中的起始地址**（读取[页表](https://docs.drshw.tech/os/4/3/#%E9%A1%B5%E8%A1%A8)）；

3. 要算出逻辑地址**在页面内的“偏移量”**；

   **页内偏移量** = 逻辑长度 % 页面长度（**取余**）

   若页面大小为`2^k`B，用二进制数表示逻辑地址，则末尾`k`位即为**页内偏移量**，其余部分表示**页号**。

4. **物理地址 = 页面地址 + 页内偏移量**。

例如：若CPU执行指令1，需要访问逻辑地址为80的内存单元，如何转化为物理地址？

逻辑地址为80的内存单元：

应该在**1号页**，该页在内存中**起始位置为450**，逻辑地址为80的内存单元相对于该页的起始地址而言，**“偏移量”应该是30**。

**故实际物理地址**为：`450 + 30 = 480`。

#### 逻辑地址结构

分页存储管理的逻辑地址结构如下所示：

<img src="https://images.drshw.tech/images/notes/image-20221022171215515.png" alt="image-20221022171215515" style="zoom:50%;" />

地址结构包含两个部分：前一部分为页号P，后一部分为业内偏移量W。在上图所示的例子中，地址长度为32位，其中0 ~ 11位为“**页内偏移量**”，或称“**页内地址**”；12 ~ 31位为“**页号**”。

+ **若有 `k` 位表示“页内偏移量”，则说明系统中一个页面的大小是`2^k`个内存单元**。
+ **若有 `m` 位表示“页号”，则说明在该系统中，一个进程最多允许有`2^m`个页面**。

#### 页表

为了能知道进程的每个页面在内存中存放的位置，操作系统要**为每个进程建立一张页表**。

![image-20221022172222799](https://images.drshw.tech/images/notes/image-20221022172222799.png)

说明：

1. 一个进程对应一张页表；

2. 进程的每一页对应一个页表项；

3. 每个**页表项**由“页号”和“块号”组成；

   `m`号内存块的起始地址就是`m * 内存块大小`；

4. 页表记录**进程页面和实际存放的内存块之间的对应关系**；

5. 每个页表项的长度是相同的，**页号是“隐含”的**。

   <img src="https://images.drshw.tech/images/notes/image-20221022172704795.png" alt="image-20221022172704795" style="zoom:50%;" />

### 4.3.3 基本地址变换机构

<img src="https://images.drshw.tech/images/notes/image-20221022195638300.png" alt="image-20221022195638300" style="zoom:50%;" />

#### 基本概念

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。

通常会在系统中设置一个**页表寄存器**（PTR），存放**页表在内存中的起始地址F**和**页表长度M**。 

进程未执行时，页表的起始地址和页表长度**放在进程控制块PCB**中，当进程被调度时，操作系统内核会将它们放到页表寄存器中。

注意：**页面大小是2的整数幂**。

#### 变换流程

设页面大小为L，逻辑地址A到物理地址E的变换过程如下：

<img src="https://images.drshw.tech/images/notes/image-20221022173751619.png" alt="image-20221022173751619" style="zoom:50%;" />

① 计算页号`P`和页内偏移量`W`（如果用十进制数手算，则`P = A/L, W = A%L`；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）；

② 比较页号`P`和页表长度`M`，若**`P ≥ M`**，则产生越界中断，否则继续执行（注意：页号是从0开始的，而页表长度至少是1，因此**`P = M`时也会越界**）；

③页表中页号`P`对应的**页表项地址 = 页表起始地址`F` + 页号`P` * 页表项长度**。取出页表项内容`b`，即为内存块号。（注意区分**页表项长度、页表长度、页面大小的区别**。**页表长度指**的是这个页面中总共有几个页表项，即总共有几个页；**页表项长度**指的是每个页表项占多大的存储空间；页面大小指的是一个页面占多大的存储空间）；

④计算`E = b*L + W`，用得到的物理地址`E`去访存（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了）。

<img src="https://images.drshw.tech/images/notes/image-20221022174934848.png" alt="image-20221022174934848" style="zoom:50%;" />

例：若页面大小 L 为 1K 字节，页号2 对应的内存块号 `b = 8`，将逻辑地址`A = 2500`转换为物理地址 E。

等价描述：某系统**按字节寻址**，逻辑地址结构中，**页内偏移量占10位**（说明一个页面大小为`2^10B = 1KB`），页号2对应的内存块号`b = 8`，将逻辑地址`A = 2500`转换为物理地址E。

① 计算页号、页内偏移量：

+ 页号`P = A/L = 2500/1024 = 2`；
+ 页内偏移量`W = A%L = 2500%1024 = 452`；

② 根据题中条件可知，页号2没有越界，其存放的内存块号`b = 8`；

③ 物理地址`E = b*L + W = 8*1024 + 425 = 8644`。

在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，**页式管理中地址是一维的**。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。

#### 对页表项大小的进一步探讨

<img src="https://images.drshw.tech/images/notes/image-20221022195237158.png" alt="image-20221022195237158" style="zoom:50%;" />

结论：理论上，页表项长度为3B即可表示内存块号的范围，但是，为了方便页表的查询，常常会让一个页表项占更多的字节，使得**每个页面恰好可以装得下整数个页表项**。进程页表通常是**装在连续的内存块**中的。

### 4.3.4 具有快表的地址变换机构

它是在基本地址变换机构的改进版本：

<img src="https://images.drshw.tech/images/notes/image-20221022210805133.png" alt="image-20221022210805133" style="zoom:50%;" />

#### 局部性原理

若有一段程序如下：

```cpp
int i = 0;
int a[100];
while (i < 100) {
    a[i] = i;
    i ++;
}
```

若将所有的指令都存放在10号内存块，所有程序中定义的变量都存放在23号内存块：

<img src="https://images.drshw.tech/images/notes/image-20221022200435901.png" alt="image-20221022200435901" style="zoom:50%;" />

该程序执行时，系统会很频繁地访问10号、23号内存块；由此引出两个概念：

+ **时间局部性**：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问；（因为程序中存在大量循环）
+ **空间局部性**：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）

时间局部性和空间局部性统称为**局部性原理**。由于局部性原理，在基本地址变换机构中，查询页表时，很可能连续多次查到的都是同一个页表项。可以利用局部性原理的特性进行优化。

#### 快表的概念

**快表**，又称**联想寄存器（TLB）**，是一种**访问速度比内存快很多**的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为**慢表**。

假设进程的前三条指令依次存放在`(0, 0), (0, 4), (0, 8)`，CPU依次执行这三条指令：

+ 首先先执行第一条指令，程序计数器PC中存放指令的逻辑地址，即页号为0，页内偏移量为0；
+ 再进行合法性检查，未越界；
+ 然后查看快表，搜索快表中与该页号对应的页表项，若有则称为**命中**，否则称为**未命中**；由于初始快表为空，故未命中；
+ 由于未命中，此时会根据页表始址查询和页号，计算出该页号对应页表项在内存中的位置，并将其**复制到快表中**；
+ 最后根据内存块号和页内偏移量，可得到物理地址，访存。

<img src="https://images.drshw.tech/images/notes/image-20221022202621119.png" alt="image-20221022202621119" style="zoom:50%;" />

+ 执行第二条指令，逻辑地址存PC，未越界；
+ 查快表时，发现该页号在快表中已经出现了，即**命中**，此时直接读取快表中的内存块号即可；
+ 最后得到物理地址，访存。

<img src="https://images.drshw.tech/images/notes/image-20221022204255293.png" alt="image-20221022204255293" style="zoom:50%;" />

+ 第三条指令也是一样，命中快表，直接读取对应内存块号并读取物理地址，访存。

由上述过程可见，快表中存放的是页表的一部分**副本**。

#### 地址变换过程

变换过程可总结为：

1. CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较；
2. 如果找到匹配的页号，说明要访问的页表项在快表中存在副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址。最后，**访问**该物理地址对应的**内存单元**。因此，若**快表命中**，则访问某个逻辑地址仅需**一次访存**即可。
3. 如果没有找到匹配的页号，则需要**访问内存中的页表**，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址。最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存（注意：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但是若快表已满，则必须按照一定的算法对旧的页表项进行替换）。

由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。因为局部性原理，一般来说快表的命中率可以达到 90% 以上。

例：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时`1μs`，访问一次内存耗时`100μs`。若快表的命中率为 90% ，那么访问一个逻辑地址的平均耗时是多少？

+ 一般系统会优先查询快表，其次查询慢表，平均耗时 ：`(1+100) * 0.9 + (1+100+100) * 0.1 = 111μs`；
+ 少数系统支持快表和慢表同时查询，此情况下平均耗时：`(1+100) * 0.9 + (100+100) * 0.1 = 110.9μs`；
+ 若未采用快表机制，则访问一个逻辑地址需要`100 + 100 = 200μs`。

显然，引入快表机制后，访问一个逻辑地址的速度提升明显。

### 4.3.5 两级页表

<img src="https://images.drshw.tech/images/notes/image-20221022221150432.png" alt="image-20221022221150432" style="zoom:50%;" />

#### 两级页表的引入

单级页表存在两个明显的问题：

+ **页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框；**
+ 没有必要让整个页表常驻内存，因为一个进程在一段时间内可能只需要访问某几个特定的页面。

对第一个问题的改进措施：

+ 可将页表再进行分组，使每个内存块刚好可以放入一个分组；
+ 另外，要为离散分配的页表再建立一张页表，称为**页目录表**，或称**外层页表**，或称**顶层页表**。

#### 两级页表的原理、地址结构

一计算机系统支持32位的逻辑地址，采用分页存储管理，页面大小为4KB，页表项为4B，则页内地址要用12位表示，剩余20位表示页号，若采用单级页表结构，逻辑地址结构如下：

<img src="https://images.drshw.tech/images/notes/image-20221022211942908.png" alt="image-20221022211942908" style="zoom:50%;" />

<img src="https://images.drshw.tech/images/notes/image-20221022212230390.png" alt="image-20221022212230390" style="zoom:50%;" />

此时页表很大，引入二级页表将其拆分，二级页表的逻辑地址结构如下：

<img src="https://images.drshw.tech/images/notes/image-20221022212421116.png" alt="image-20221022212421116" style="zoom:50%;" />

一级页号用10位二进制数表示，对应**页目录表**的范围；二级页号也是10位，对应二级页表中的页号：

<img src="https://images.drshw.tech/images/notes/image-20221022212559275.png" alt="image-20221022212559275" style="zoom:50%;" />

#### 地址变换过程

转换分为三个步骤：

1. 按照地址结构将逻辑地址拆分成三个部分；
2. 从PCB中读出页目录始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置；
3. 根据二级页号查表，找到最终想访问的内存块号；
4. 结合页内偏移量得到物理地址。

举个例子，欲将逻辑地址`(0000000000, 0000000001, 111111111111)`转换为物理地址（用十进制表示），二级页表和内存的情况如下：

<img src="https://images.drshw.tech/images/notes/image-20221022214314545.png" alt="image-20221022214314545" style="zoom:50%;" />

最终好访问的内存块号为4，该内存块的起始地址为`4*4096 = 16384`，页内偏移量为1023，因此最终的物理地址为：`16384 + 1023 = 17507`。

对单级页表存在的[第二个问题](https://docs.drshw.tech/os/4/3/#%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%BC%95%E5%85%A5)的改进措施：

+ 可以在需要访问页面时才把页面调入内存（下一章[虚拟存储技术](https://docs.drshw.tech/os/5/1/)会详细介绍）；

+ 可以在页表项中增加一个**标志位**，用于表示该页面是否已经调入内存：

  <img src="https://images.drshw.tech/images/notes/image-20221022220335166.png" alt="image-20221022220335166" style="zoom:50%;" />

  若想访问的页面不在内存中，则产生缺页中断（内中断），然后将目标页面从外存调入内存。

#### 需要注意的几个细节

① 若采用多级页表机制，则**各级页表的大小不能超过一个页面**：

<img src="https://images.drshw.tech/images/notes/image-20221022220716029.png" alt="image-20221022220716029" style="zoom:50%;" />

② 两级页表的**访存次数**分析（假设没有快表机构）：

+ 第一次访存：访问内存中的页目录表；
+ 第二次访存：访问内存中的二级页表；
+ 第三次访存：访问目标的内存单元；

`n`级页表的访存次数为`n + 1`次。相较于单级页表，多级页表需要**更多的访存次数**，这也是多级页表的缺点之一。
