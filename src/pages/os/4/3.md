---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 4.3 基本分页存储管理方式

### 4.3.1 非连续分配方式介绍

#### 非连续分配方式的引入

前面讲的连续分配方式有如下的缺点：

1. 对于固定分区分配方式：缺乏灵活性，会产生大量的内部碎片，内存的利用率很低；

   <img src="https://images.drshw.tech/images/notes/image-20221021231728155.png" alt="image-20221021231728155" style="zoom:50%;" />

2. 对于动态分区分配方式：会产生很多外部碎片，虽然可以用“紧凑”技术来处理，但是“紧凑”的时间代价很高。

<img src="https://images.drshw.tech/images/notes/image-20221021231740432.png" alt="image-20221021231740432" style="zoom:50%;" />

如果允许将一个进程分散地装入到许多不相邻的分区中，便可充分地利用内存，而无需再进行“紧凑”。

基于这一思想，产生了**非连续分配方式**，或者称为“离散分配方式”，即为用户进程分配的可以是一些**分散的内存空间**。

非连续分配方式可分为三种类型：

<img src="https://images.drshw.tech/images/notes/image-20221021234555360.png" alt="image-20221021234555360" style="zoom:50%;" />

#### 非连续分配的基本思路

假设有一个大小为23MB的进程A，若按固定分区分配算法，每个分区大小只有10MB，显然是放不下的。

若采用非连续分配的方式，若允许进程占用多个分区，那么可以**把进程拆分成 `10MB + 10MB + 3MB` 三个部分**，再把这三个部分分别放到三个分区中（这些**分区不要求连续**）：

<img src="https://images.drshw.tech/images/notes/image-20221021234758186.png" alt="image-20221021234758186" style="zoom:50%;" />→<img src="https://images.drshw.tech/images/notes/image-20221021235248612.png" alt="image-20221021235248612" style="zoom:50%;" />

进程A的最后一个部分是3MB，放入分区后会产生7MB的**内部碎片**。

若每个分区大小为2MB，那么进程A可以拆分成`11 * 2MB + 1MB`共12个部分，只有最后一部分1MB占不满分区，会产生1MB的内部碎片。

显然，**如果把分区大小设置的更小一些，内部碎片会更小，内存利用率会更高**。

基本分页存储管理的思想：把内存分为一个个相等的**小分区**，再按照分区大小将进程拆分成一个个小部分。

### 4.3.2 分页存储管理的基本概念

<img src="https://images.drshw.tech/images/notes/image-20221022172821316.png" alt="image-20221022172821316" style="zoom:50%;" />

#### 基本概念

将内存空间分为一个个**大小相等的分区**（比如：每个分区4KB），每个分区就是一个“**页框**”，或称“**页帧**”、“**内存块**”、“**物理块**”。每个页框有一个编号，即“**页框号**”（或者“**内存块号**”、“**页帧号**”、“**物理块号**”）。页框号***从0开始***。

将用户进程的地址空间也分为***与页框大小相等***的一个个区域，称为“**页**”或“**页面**”。每个页面也有一个编号，即“页号”，页号也是***从0开始***。

（注：进程的最后一个页面可能没有一个页框那么大。因此，**页框不能太大，否则可能产生过大的内部碎片**）

操作系统**以页框为单位为各个进程分配**内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的**页面**与内存的**页框**有**一一对应**的关系：

<img src="https://images.drshw.tech/images/notes/image-20221022164331896.png" alt="image-20221022164331896" style="zoom:50%;" />→ <img src="https://images.drshw.tech/images/notes/image-20221022164408777.png" alt="image-20221022164408777" style="zoom:50%;" />

各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。

#### 地址的转换

将进程地址分页后，操作系统需要实现逻辑地址到物理地址的转换。

类似[动态重定位的装入方式](https://docs.drshw.tech/os/4/1/#%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D)，采用分页技术后，一个进程的逻辑地址会被分为一个个页面，各个页面会被离散地装入内存中：

<img src="https://images.drshw.tech/images/notes/image-20221022165158024.png" alt="image-20221022165158024" style="zoom:50%;" />

要将需要访问的逻辑地址转换为物理地址，要经历如下四个步骤：

1. 要算出逻辑地址对应的**页号**；

   **页号** = 逻辑地址 / 页面长度（**取整**）

2. 要知道该页号对应**页面在内存中的起始地址**（读取[页表](https://docs.drshw.tech/os/4/3/#%E9%A1%B5%E8%A1%A8)）；

3. 要算出逻辑地址**在页面内的“偏移量”**；

   **页内偏移量** = 逻辑长度 % 页面长度（**取余**）

   若页面大小为`2^k`B，用二进制数表示逻辑地址，则末尾`k`位即为**页内偏移量**，其余部分表示**页号**。

4. **物理地址 = 页面地址 + 页内偏移量**。

例如：若CPU执行指令1，需要访问逻辑地址为80的内存单元，如何转化为物理地址？

逻辑地址为80的内存单元：

应该在**1号页**，该页在内存中**起始位置为450**，逻辑地址为80的内存单元相对于该页的起始地址而言，**“偏移量”应该是30**。

**故实际物理地址**为：`450 + 30 = 480`。

#### 逻辑地址结构

分页存储管理的逻辑地址结构如下所示：

<img src="https://images.drshw.tech/images/notes/image-20221022171215515.png" alt="image-20221022171215515" style="zoom:50%;" />

地址结构包含两个部分：前一部分为页号P，后一部分为业内偏移量W。在上图所示的例子中，地址长度为32位，其中0~11位为“页内偏移量”，或称“页内地址”；12~31位为**“页号”。

+ **若有 `k` 位表示“页内偏移量”，则说明系统中一个页面的大小是`2^k`个内存单元**。
+ **若有 `m` 位表示“页号”，则说明在该系统中，一个进程最多允许有`2^m`个页面**。

#### 页表

为了能知道进程的每个页面在内存中存放的位置，操作系统要**为每个进程建立一张页表**。

![image-20221022172222799](https://images.drshw.tech/images/notes/image-20221022172222799.png)

说明：

1. 一个进程对应一张页表；

2. 进程的每一页对应一个页表项；

3. 每个**页表项**由“页号”和“块号”组成；

   `m`号内存块的起始地址就是`m * 内存块大小`；

4. 页表记录**进程页面和实际存放的内存块之间的对应关系**；

5. 每个页表项的长度是相同的，**页号是“隐含”的**。

   <img src="https://images.drshw.tech/images/notes/image-20221022172704795.png" alt="image-20221022172704795" style="zoom:50%;" />

### 4.3.3 基本地址变换机构

#### 基本概念

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。

通常会在系统中设置一个**页表寄存器**（PTR），存放**页表在内存中的起始地址F**和**页表长度M**。 

进程未执行时，页表的起始地址和页表长度**放在进程控制块PCB**中，当进程被调度时，操作系统内核会将它们放到页表寄存器中。

注意：**页面大小是2的整数幂**。

#### 变换流程

设页面大小为L，逻辑地址A到物理地址E的变换过程如下：

<img src="https://images.drshw.tech/images/notes/image-20221022173751619.png" alt="image-20221022173751619" style="zoom:50%;" />

① 计算页号`P`和页内偏移量`W`（如果用十进制数手算，则`P = A/L, W = A%L`；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）；

② 比较页号`P`和页表长度`M`，若**`P ≥ M`**，则产生越界中断，否则继续执行（注意：页号是从0开始的，而页表长度至少是1，因此**`P = M`时也会越界**）；

③页表中页号`P`对应的**页表项地址 = 页表起始地址`F` + 页号`P` * 页表项长度**。取出页表项内容`b`，即为内存块号。（注意区分**页表项长度、页表长度、页面大小的区别**。**页表长度指**的是这个页面中总共有几个页表项，即总共有几个页；**页表项长度**指的是每个页表项占多大的存储空间；页面大小指的是一个页面占多大的存储空间）；

④计算`E = b*L + W`，用得到的物理地址`E`去访存（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了）。

<img src="https://images.drshw.tech/images/notes/image-20221022174934848.png" alt="image-20221022174934848" style="zoom:50%;" />

例：若页面大小 L 为 1K 字节，页号2 对应的内存块号 `b = 8`，将逻辑地址`A = 2500`转换为物理地址 E。

