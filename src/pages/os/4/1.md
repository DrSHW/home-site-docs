---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 4.1 存储器管理的基本概念

### 4.1.1 内存管理的概念

#### 什么是内存

内存是用于存放数据的硬件。程序执行前**需要先放到内存中才能被CPU处理**。

可以使用内存地址的方式，区分不同程序存放数据的位置。内存地址从0开始，**每一个地址**对应**一个存储单元**。若计算机**按字节编址**，则**每个存储单元大小**为**1字节**，即1B，8个二进制位；若一个**字长为16位**的计算机**按字编址**，则每个存储单元大小为1个字，每个字的大小为16个二进制位。

#### 什么是内存管理

内存管理是操作系统设计中最重要和最复杂的内容之一。计算机硬件一直在发展，内容容量也在不断增长，但是仍然不可能将所有用户进程和系统所需要的全部程序和数据放入主存中，所以操作系统必须将内存空间进行合理的划分和有效的动态分配。操作系统**对内存的划分和动态分配**，就是内存管理的概念。

内存管理主要负责：

1. **内存空间的分配和回收**

   即需要处理：进程可以资源可以放入内存的哪些位置、怎么记录空闲的内存区域、怎么将进程占用的内存资源回收等问题。

2. 需要提供某种技术，从逻辑上**对内存资源进行扩充**

   一般有三种技术可以实现内存的扩充：

   <img src="https://images.drshw.tech/images/notes/image-20221017181104626.png" alt="image-20221017181104626" style="zoom:80%;" />

   其中虚拟存储技术会在下一章介绍，覆盖与交换技术我们会在[本节最后](https://docs.drshw.tech/os/4/1/#414-%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF)介绍。

3. 操作系统需要提供地址转换功能，负责程序的**逻辑地址与物理地址的转换**

   为了使编程更方便，程序员写程序是应该只需要关注指令、数据的逻辑地址。而**逻辑地址到物理地址的转换**（这个过程称为**地址重定位**）应该由操作系统负责，这样就保证了程序员写程序时无需再关注物理内存的实际情况。

4. 需要提供**内存保护**功能

   即需要保证各进程在各自存储空间内运行，互不干扰。

   可采取两种方式进行内存保护：

   + 方法一：在CPU中**设置一对上、下限寄存器**，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界；

   + 方法二：采用**重定位寄存器**（又称**基址寄存器**）和**界地址寄存器**（又称**限长寄存器**）进行越界检查。重定位寄存器中存放的是进程的**起始物理地址**；界地址寄存器中存放的是进程的**最大逻辑地址**。

     <img src="https://images.drshw.tech/images/notes/image-20221017173728660.png" alt="image-20221017173728660" style="zoom:50%;" />

从写程序到程序运行，要经历以下过程：

<img src="https://images.drshw.tech/images/notes/image-20221017170623899.png" alt="image-20221017170623899" style="zoom:50%;" />

图中一些名词的具体说明：

+ **编译**：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言**翻译为机器语言**）；
+ **链接**：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块；
+ **装入**（装载）：由装入程序将装入模块装入内存运行。

### 4.1.2 程序的装入

装入的三种方式如下（用三种不同的方法完成逻辑地址到物理地址的转换）：

<img src="https://images.drshw.tech/images/notes/image-20221017172637860.png" alt="image-20221017172637860" style="zoom:50%;" />

#### 绝对装入

即在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。

<img src="https://images.drshw.tech/images/notes/image-20221017174102465.png" alt="image-20221017174102465" style="zoom:50%;" />

绝对装入**只适用于单道程序环境**。

程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是**编译或汇编时**转换为绝对地址。

#### 静态重定位

又称**可重定位装入**。编译、连接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“**重定位**”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。

<img src="https://images.drshw.tech/images/notes/image-20221017174441214.png" alt="image-20221017174441214" style="zoom:50%;" />

其特点是在一个作业装入内存时，**必须分配其要求的全部内存空间**，如果没有足够的内存，就不能装入该作业；作业一旦进入内存后，**在运行期间就不能再移动**，也不能在申请内存空间。

#### 动态重定位

又称**动态运行时装入**。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把地址转换为物理地址，而是**把地址转换推迟到程序真正要执行时才进行**。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个**重定位寄存器**的支持。

<img src="https://images.drshw.tech/images/notes/image-20221017175024701.png" alt="image-20221017175024701" style="zoom:50%;" />

<img src="https://images.drshw.tech/images/notes/image-20221017175134226.png" alt="image-20221017175134226" style="zoom:48%;" />

采用动态重定位时**允许程序在内存中发生移动**，并且可将程序分配到**不连续**的存储区中；在程序运行前只需装入它的**部分代码**即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个大得多的地址空间。

### 4.1.3 程序的链接

链接的三种方式如下：

<img src="https://images.drshw.tech/images/notes/image-20221017175757462.png" alt="image-20221017175757462" style="zoom:100%;" />

#### 静态链接

即在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。

<img src="https://images.drshw.tech/images/notes/image-20221017175924205.png" alt="image-20221017175924205" style="zoom:50%;" />

#### 装入时动态链接

将各目标模块装入内存时，边装入边链接的链接方式。

<img src="https://images.drshw.tech/images/notes/image-20221017180044229.png" alt="image-20221017180044229" style="zoom:50%;" />

#### 运行时动态链接

在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。

<img src="https://images.drshw.tech/images/notes/image-20221017180513488.png" alt="image-20221017180513488" style="zoom:50%;" />

### 4.1.4 覆盖与对换技术

<img src="https://images.drshw.tech/images/notes/image-20221017183938225.png" alt="image-20221017183938225" style="zoom:50%;" />

#### 覆盖技术

早期的计算机内存很小，比如IBM推出的第一台PC机最大只支持1MB大小的内存。因此经常会出现内存大小不够的情况。

于是人们引入了**覆盖技术**，用来**解决“程序大小超过物理内存总和”的问题**。

覆盖技术的思想：将**程序分为多个段**（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。

内存分为**一个“固定区”**和**若干个“覆盖区”**，需要常驻内存的段放在“**固定区**”中，**调入后就不再调出**（除非运行结束）；不常用的段放在“**覆盖区**”，**需要用到时调入内存，用不到时调出内存**。

<img src="https://images.drshw.tech/images/notes/image-20221017182836467.png" alt="image-20221017182836467" style="zoom:50%;" />

**必须由程序员声明覆盖结构**，操作系统完成自动覆盖。**缺点：对用户不透明**，增加了用户编程负担。

覆盖技术只用于早期的操作系统中，现已成为历史。

#### 对换技术

对换（交换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时**换出**外存，将外存中某些已具备运行条件的进程**换入**内存（进程在内存与磁盘间**动态调度**，其实就是处理机调度中的[**中级调度**](https://docs.drshw.tech/os/3/1/#%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6)）。

<img src="https://images.drshw.tech/images/notes/image-20221017183603518.png" alt="image-20221017183603518" style="zoom:50%;" />

在外存（磁盘）中，保存被换出进程的位置：

+ 具有对换功能的操作系统中，通常把磁盘空间分为**文件区**和**对换区**两部分。**文件区**主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理**采用离散分配方式**；**对换区**空间只占磁盘空间的小部分，**被换出的进程数据就存放在对换区**。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理**主要追求换入换出速度**，因此通常对换区**采用连续分配方式**（学过文件管理章节后即可理解）。总之，**对换区的 I/O 速度比文件区的更快**。

交换的时机：

+ 交换通常在许多进程运行且内存吃紧时进行，系统负荷降低时就暂停。

  例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。

应该被优先换出的进程种类：

+ 可优先换出阻塞进程；

+ 可换出优先级低的进程；

+ 为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间。

  （**注意：PCB会常驻内存**，不会被换出外存）
