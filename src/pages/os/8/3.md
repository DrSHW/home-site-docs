---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 8.3 磁盘结构与磁盘调度算法

### 8.3.1 磁盘的结构

<img src="https://images.drshw.tech/images/notes/image-20221114212337542.png" alt="image-20221114212337542" style="zoom:50%;" />

#### 磁盘、磁道、扇区的概念

磁盘表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据：

<img src="https://img.zmtc.com/2019/0905/20190905060018822.jpg" alt="查看源图像" style="zoom:90%;" />

磁道和扇区：

<img src="https://images.drshw.tech/images/notes/image-20221114214939368.png" alt="image-20221114214939368" style="zoom:50%;" />

#### 数据读写方式

磁盘需要读/写数据时，需要由磁头臂带动磁头，将其移动到想要读/写的扇区所在的磁道。磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读/写操作。

#### 盘面、柱面的概念

物理结构：

<img src="https://images.drshw.tech/images/notes/image-20221114215456751.png" alt="image-20221114215456751" style="zoom:50%;" />

可用**`(柱面号, 盘面号, 扇区号)`**来定位任意一个“磁盘块”。在[外存的组织方式](https://docs.drshw.tech/os/8/1/)小节中，我们经常提到文件数据存放在外存中的几号块，这个块号就可以转换成`(柱面号, 盘面号, 扇区号)`的地址形式。

根据地址读取一个块的过程：

1. 根据“柱面号”移动磁臂，让磁头指向指定柱面；
2. 激活指定盘面对应的磁头；
3. 磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写。

#### 磁盘的分类

按磁头是否可移动分类：

+ 磁头可以移动的磁盘称为**活动头磁盘**。磁臂可以来回伸缩来带动磁头定位磁道：

  <img src="https://images.drshw.tech/images/notes/image-20221114220342285.png" alt="image-20221114220342285" style="zoom:50%;" />

+ 磁头不可移动的磁盘称为**固定头磁盘**。这种磁盘中每个磁道有一个磁头：

  <img src="https://images.drshw.tech/images/notes/image-20221114220409383.png" alt="image-20221114220409383" style="zoom:50%;" />

按盘片是否可更换分类：

+ 盘片可以更换的称为**可换盘磁盘**；
+ 盘片不可更换的称为**固定盘磁盘**。

### 8.3.2 磁盘的单次读写时间

一次磁盘读/写操作所需的时间分为：

<img src="https://images.drshw.tech/images/notes/image-20221114223105288.png" alt="image-20221114223105288" style="zoom:60%;" />

**寻找时间（寻道时间）**`TS`：在读/写数据前，将磁头移动到指定磁道所花的时间：

+ **启动磁头臂**是需要时间的。假设耗时为`s`；
+ **移动磁头**也是需要时间的。假设磁头匀速运动，每跨越一个磁道耗时为`m`，总共需要跨越`n`条磁道，则：**寻道时间`TS = s + m*n`**。

目前的硬盘移动一个磁道大约需要0.2ms，磁臂启动时间约为2ms。

**延迟时间**`TR`：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为`r`（单位：转/秒，或 转/分），则**平均所需的延迟时间`TR = (1/2) * (1/r) = 1/2r`** （`1/r`就是转一圈需要的时间。找到目标扇区平均需要转半圈，因此要再乘`1/2`）。

硬盘的典型转速为5400 转/分，或 7200 转/分。

**传输时间**`Tt`：从磁盘读出或向磁盘写入数据所经历的时间。假设磁盘转速为`r`，此次读/写的字节数为`b`，每个磁道上的字节数为`N`，则：**传输时间`Tt = (1/r) * (b/N) = b/rN`** （每个磁道上可存`N`字节的数据，因此`b`字节的数据需要`b/N`个磁道才能存储。而读/写一个磁道所需的时间刚好又是转一圈所需要的时间`1/r`）。

因此，总的平均存取时间`Ta = Ts + 1/2r + b/(rN)`。

可以发现，延迟时间和传输时间都与磁盘转速相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间，但是操作系统可以使用一些算法优化寻道时间，即磁盘调度算法。

磁盘调度算法主要有以下几种：

<img src="https://images.drshw.tech/images/notes/image-20221114223039773.png" alt="image-20221114223039773" style="zoom:60%;" />

### 8.3.3 先来先服务算法（FCFS）

即根据进程请求访问磁盘的先后顺序进行调度。

假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问`55, 58, 39, 18, 90, 160, 150, 38, 184`号磁道，按照FCFS的规则，按照请求到达的顺序，磁头需要依次移动到`55, 58, 39, 18, 90, 160, 150, 38, 184`号磁道：

![image-20221114223515016](https://images.drshw.tech/images/notes/image-20221114223515016.png)

磁头总共移动了 `45+3+19+21+72+70+10+112+146 = 498`个磁道，响应一个请求平均需要移动`489/9 = 55.3`个磁道（平均寻找长度）。

优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过得去；

缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。

### 8.3.4 最短寻找时间优先算法（SSTF）

SSTF 算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。（其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优）

假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问`55, 58, 39, 18, 90, 160, 150, 38, 184`号磁道，磁头移动次序：

<img src="https://images.drshw.tech/images/notes/image-20221114224708586.png" alt="image-20221114224708586" style="zoom:50%;" />

磁头总共移动了 `(100-18) + (184-18) = 248`个磁道，响应一个请求平均需要移动`248/9 = 27.5`个磁道（平均寻找长度）。

优点：性能较好，平均寻道时间短；

缺点：**可能产生“饥饿”现象**。（例如：在上面的例子中，若在处理18号磁道的访问请求时又来了一个38号磁道的访问请求，处理38号磁道的访问请求时又来了一个18号磁道的访问请求。如果有源源不断的18号、38号磁道的访问请求到来的话，150、160、184号的访问请求就永远得不到满足，从而产生“饥饿”现象）

### 8.3.5 扫描算法（电梯算法、SCAN）

SSTF算法会产生饥饿的原因在于：磁头有可能在一个小区域内来回移动。

为了防止这个问题，引入了**扫描算法SCAN**，其主要思想为：**只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动**。由于磁头移动的方式很像电梯，因此也叫**电梯算法**。

假设某磁盘的磁道为`0~200`号，磁头的初始位置是100号磁道，且**此时磁头正在往磁道号增大的方向移动**，有多个进程先后陆续地请求访问`55, 58, 39, 18, 90, 160, 150, 38, 184`号磁道，磁头移动次序：

<img src="https://images.drshw.tech/images/notes/image-20221114225800114.png" alt="image-20221114225800114" style="zoom:50%;" />

磁头总共移动了 `(200-100) + (200-18) = 282`个磁道，响应一个请求平均需要移动`282/9 = 31.3`个磁道（平均寻找长度）。

优点：性能较好，平均寻道时间较短，**不会产生饥饿现象**；

缺点：

1. 只有到达最边上的磁道时才能改变磁头方向，事实上，处理了184号磁道的访问请求后，不再需要往右移动磁头了；
2. SCAN算法对于各个位置磁道的响应频率不平均（如：假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离；而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了）

### 8.3.6 LOOK 调度算法

扫描算法（SCAN）中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。由此引入了**LOOK 调度算法**：**如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向**。（边移动边观察，因此称作 LOOK）

假设某磁盘的磁道为`0~200`号，磁头的初始位置是100号磁道，且**此时磁头正在往磁道号增大的方向移动**，有多个进程先后陆续地请求访问`55, 58, 39, 18, 90, 160, 150, 38, 184`号磁道，磁头移动次序：

![image-20221114230813443](https://images.drshw.tech/images/notes/image-20221114230813443.png)

磁头总共移动了 `(184-100) + (184-18) = 250`个磁道，响应一个请求平均需要移动`250/9 = 27.5`个磁道（平均寻找长度）。

优点：比起SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短；

### 8.3.7 循环扫描算法（C-SCAN）

SCAN算法对于各个位置磁道的响应频率不平均，由此引入了**C-SCAN算法**：规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而**返回时直接快速移动至起始端而不处理任何请求**。

假设某磁盘的磁道为`0~200`号，磁头的初始位置是100号磁道，且**此时磁头正在往磁道号增大的方向移动**，有多个进程先后陆续地请求访问`55, 58, 39, 18, 90, 160, 150, 38, 184`号磁道，磁头移动次序：

<img src="https://images.drshw.tech/images/notes/image-20221114231335929.png" alt="image-20221114231335929" style="zoom:50%;" />

磁头总共移动了 `(200-100) + (200-0) + (90-0) = 390`个磁道，响应一个请求平均需要移动`390/9 = 43.3`个磁道（平均寻找长度）。

优点：比起SCAN算法来，对于各个位置磁道的响应频率很平均；

缺点：只有到达了最边上的磁道时才能改变磁头移动方向。事实上，处理了184号磁道的访问请求之后，就不需要再往右移动磁头了；并且，磁头返回时其实只需要返回到18号磁道即可，不需要返回到最边缘的磁道。另外，比起SCAN算法来，平均寻道时间更长。

### 8.3.8 C-LOOK 调度算法

C-SCAN 算法的主要缺点是只有到达最边上的磁道时才能改变磁头的移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。由此引入了C-LOOK算法：若磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。

假设某磁盘的磁道为`0~200`号，磁头的初始位置是100号磁道，且**此时磁头正在往磁道号增大的方向移动**，有多个进程先后陆续地请求访问`55, 58, 39, 18, 90, 160, 150, 38, 184`号磁道，磁头移动次序：

<img src="https://images.drshw.tech/images/notes/image-20221114232116524.png" alt="image-20221114232116524" style="zoom:50%;" />

磁头总共移动了 `(184-100) + (184-0) + (90-0) = 322`个磁道，响应一个请求平均需要移动`322/9 = 35.8`个磁道（平均寻找长度）。

优点：比起C-SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短；

