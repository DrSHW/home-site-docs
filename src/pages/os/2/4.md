---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 2.4 经典的进程同步问题

### 2.4.1 生产者-消费者问题

#### 问题描述

系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注: 这里的“产品”理解为某种数据）

生产者、消费者共享一个初始为空、大小为`n`的缓冲区。

只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。

只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。

此处的缓冲区时临界资源，各进程必须互斥地访问。

如何使用信号量机制（`P`、`V`操作）实现生产者、消费者进程的这些功能？

#### 分析步骤

PV操作题目一般分析步骤：

1. **关系分析**。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。

   就本题而言：

   + 缓冲区访问需要**互斥**；
   + 缓冲区满时，生产者要等待消费者取走产品，才能继续放产品，为**同步**关系；
   + 缓冲区空时，消费者要等待生产者放入产品，否则才能取走，为**同步**关系。

2. **整理思路**。根据各进程的操作流程确定P、V操作的大致顺序。

   就本题而言：

   + 生产者每次要消耗（`P`）一个空闲缓冲区，并生产（`V`）一个产品；
   + 消费者每次要消耗（`P`）一个产品，并释放一个空闲缓冲区（`V`）；
   + 往缓冲区放入/取走产品需要互斥。

3. **设置信号量**。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）

   就本题而言：

   + 刚开始空闲缓冲区的数量为`n`，非空闲缓冲区（产品）的数量为0；
   + 需要互斥信号量。

于是，我们可以得到这样的结论：

```cpp
int mutex = 1;			// 互斥信号量，实现对缓冲区的互斥访问
int empty = n;			// 同步信号量，表示空闲缓冲区的数量
int full = 0;			// 同步信号量，表示产品的数量，即非空缓冲区的数量
```

生产者进程需要进行的操作：

```cpp
producer (){
    while(true){
        生产一个产品;
        P(empty);		// 实现同步，消耗一个空闲缓冲区
        P(mutex);		// 实现互斥（即一对在同一进程中的P、V操作）
        把产品放入缓冲区;
        V(mutex);		// 实现互斥
        V(full);		// 实现同步，增加一个产品
    }
}
```

消费者进程需要执行的操作：

```cpp
consumer (){
    while(true){
        P(full);		// 实现同步，消耗一个产品（空闲缓冲区）
        P(mutex);		// 实现互斥（即一对在同一进程中的P、V操作）
      	从缓冲区取出一个产品;
        V(mutex);		// 实现互斥
        V(empty);		// 实现同步，增加一个空闲
        使用产品;
    }
}
```

即可实现。

要注意，代码中的**相邻`P`操作不可交换**：

<img src="https://images.drshw.tech/images/notes/image-20221008225520189.png" alt="image-20221008225520189" style="zoom:60%;" />

### 2.4.2 多生产者-多消费者问题

#### 问题描述

桌子上有一只盘子，每次孩子能向其中放入一个水果。爸爸专向盘子中放入苹果，妈妈专向盘子中放入橘子，女儿专等吃盘子中的苹果，儿子专等吃盘子中的橘子。只有盘子为空时，爸爸或妈妈才可向盘子中放一只水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。请用PV操作实现上述过程。

#### 分析步骤

将问题抽象化：

爸爸和妈妈可看作生产者进程1、生产者进程2；儿子和女儿可看作消费者进程1、消费者进程2。盘子可视为一个大小为1，初始为空的缓冲区。

1. 关系分析：

   + 互斥关系：对缓冲区（盘子）的访问要互斥地进行；

   + 同步关系（一前一后）：

     1. 父亲将苹果放入盘子后，女儿才能取苹果；
     2. 母亲将橘子放入盘子后，儿子才能取橘子；
     3. 只有**盘子为空**时，**父亲或母亲**才能放入水果；（盘子为空这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果）

     <img src="https://images.drshw.tech/images/notes/image-20221008231740027.png" alt="image-20221008231740027" style="zoom:50%;" />

2. 整理思路：

   根据上面的分析，我们可以在前驱图上标明PV操作的时机：

   <img src="https://images.drshw.tech/images/notes/image-20221008231526486.png" alt="image-20221008231526486" style="zoom:50%;" />

3. 设置信号量：

   <img src="https://images.drshw.tech/images/notes/image-20221008231932086.png" alt="image-20221008231932086" style="zoom:50%;" />

于是，我们可以得到这样的结论：

```cpp
int mutex = 1;			// 实现互斥访问盘子
int apple = 0;			// 盘子中有几个苹果
int orange = 0;			// 盘子中有几个橘子
int plate = 1;			// 盘子中还可以放多少个水果
```

父亲进程需要的操作：

```cpp
dad (){
    while (true){
        准备一个苹果;
        P(plate);
        P(mutex);
        将苹果放入盘子;
        V(mutex);
        V(apple);
    }
}
```

母亲进程需要的操作：

```cpp
mom (){
    while (true){
        准备一个橘子;
        P(plate);
        P(mutex);
        将橘子放入盘子;
        V(mutex);
        V(orange);
    }
}
```

儿子进程需要的操作：

```cpp
son (){
    while (true){
        P(orange);
        P(mutex);
        从盘子中取出橘子;
        V(mutex);
        V(plate);
        吃掉橘子;
    }
}
```

女儿进程需要的操作：

```cpp
daughter (){
    while (true){
        P(apple);
        P(mutex);
        从盘子中取出苹果;
        V(mutex);
        V(plate);
        吃掉苹果;
    }
}
```

其实，在本题中，即使不设置互斥信号量`mutex`，也不会出现多个进程访问盘子的现象：

<img src="https://images.drshw.tech/images/notes/image-20221008232850620.png" alt="image-20221008232850620" style="zoom:50%;" />

原因在于：本题中缓冲区大小为1，在任何时刻，`apple`、`orange`、`plate`三个同步信号量最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区。若缓冲区大小为2，则会产生冲突问题。

总结：

<img src="https://images.drshw.tech/images/notes/image-20221008233403292.png" alt="image-20221008233403292" style="zoom:50%;" />

### 2.4.3 吸烟者问题



### 2.4.4 读者-写者问题



### 2.4.5 哲学家进餐问题