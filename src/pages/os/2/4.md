---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 2.4 经典的进程同步问题

### 2.4.1 生产者-消费者问题

#### 问题描述

系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注: 这里的“产品”理解为某种数据）

生产者、消费者共享一个初始为空、大小为`n`的缓冲区。

只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。

只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。

此处的缓冲区时临界资源，各进程必须互斥地访问。

如何使用信号量机制（`P`、`V`操作）实现生产者、消费者进程的这些功能？

#### 分析步骤

PV操作题目一般分析步骤：

1. **关系分析**。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。

   就本题而言：

   + 缓冲区访问需要**互斥**；
   + 缓冲区满时，生产者要等待消费者取走产品，才能继续放产品，为**同步**关系；
   + 缓冲区空时，消费者要等待生产者放入产品，否则才能取走，为**同步**关系。

2. **整理思路**。根据各进程的操作流程确定P、V操作的大致顺序。

   就本题而言：

   + 生产者每次要消耗（`P`）一个空闲缓冲区，并生产（`V`）一个产品；
   + 消费者每次要消耗（`P`）一个产品，并释放一个空闲缓冲区（`V`）；
   + 往缓冲区放入/取走产品需要互斥。

3. **设置信号量**。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）

   就本题而言：

   + 刚开始空闲缓冲区的数量为`n`，非空闲缓冲区（产品）的数量为0；
   + 需要互斥信号量。

#### 代码实现

信号量设置：

```cpp
semaphore mutex = 1;	// 互斥信号量，实现对缓冲区的互斥访问
semaphore empty = n;	// 同步信号量，表示空闲缓冲区的数量
semaphore full = 0;	// 同步信号量，表示产品的数量，即非空缓冲区的数量
```

生产者进程需要进行的操作：

```cpp
producer (){
    while(true){
        生产一个产品;
        P(empty);	// 实现同步，消耗一个空闲缓冲区
        P(mutex);	// 实现互斥（即一对在同一进程中的P、V操作）
        把产品放入缓冲区;
        V(mutex);	// 实现互斥
        V(full);	// 实现同步，增加一个产品
    }
}
```

消费者进程需要执行的操作：

```cpp
consumer (){
    while(true){
        P(full);	// 实现同步，消耗一个产品
        P(mutex);	// 实现互斥（即一对在同一进程中的P、V操作）
      	从缓冲区取出一个产品;
        V(mutex);	// 实现互斥
        V(empty);	// 实现同步，增加一个空闲缓冲区
        使用产品;
    }
}
```

即可实现。书中给出的代码实现，不过是将“放入产品”和“使用产品”的过程也实现了而已，整体流程与上方的一致。

要注意，代码中的**相邻`P`操作不可交换**：

使用Python的可视化代码实现：[代码地址](https://github.com/DrSHW/OS-experiments/blob/main/%E5%AE%9E%E9%AA%8C%E4%B8%80-%E6%9C%B4%E7%B4%A0%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85%20-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98.py)。

<img src="https://images.drshw.tech/images/notes/image-20221008225520189.png" alt="image-20221008225520189" style="zoom:60%;" />

### 2.4.2 多生产者-多消费者问题

#### 问题描述

桌子上有一只盘子，每次孩子能向其中放入一个水果。爸爸专向盘子中放入苹果，妈妈专向盘子中放入橘子，女儿专等吃盘子中的苹果，儿子专等吃盘子中的橘子。只有盘子为空时，爸爸或妈妈才可向盘子中放一只水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。请用PV操作实现上述过程。

#### 分析步骤

将问题抽象化：

爸爸和妈妈可看作生产者进程1、生产者进程2；儿子和女儿可看作消费者进程1、消费者进程2。盘子可视为一个大小为1，初始为空的缓冲区。

1. 关系分析：

   + 互斥关系：对缓冲区（盘子）的访问要互斥地进行；

   + 同步关系（一前一后）：

     1. 父亲将苹果放入盘子后，女儿才能取苹果；
     2. 母亲将橘子放入盘子后，儿子才能取橘子；
     3. 只有**盘子为空**时，**父亲或母亲**才能放入水果；（盘子为空这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果）

     <img src="https://images.drshw.tech/images/notes/image-20221008231740027.png" alt="image-20221008231740027" style="zoom:50%;" />

2. 整理思路：

   根据上面的分析，我们可以在前驱图上标明PV操作的时机：

   <img src="https://images.drshw.tech/images/notes/image-20221008231526486.png" alt="image-20221008231526486" style="zoom:50%;" />

3. 设置信号量：

   <img src="https://images.drshw.tech/images/notes/image-20221008231932086.png" alt="image-20221008231932086" style="zoom:50%;" />

#### 代码实现

信号量设置：

```cpp
semaphore mutex = 1;		// 实现互斥访问盘子
semaphore apple = 0;		// 盘子中有几个苹果
semaphore orange = 0;		// 盘子中有几个橘子
semaphore plate = 1;		// 盘子中还可以放多少个水果
```

父亲进程需要的操作：

```cpp
dad (){
    while (true){
        准备一个苹果;
        P(plate);
        P(mutex);
        将苹果放入盘子;
        V(mutex);
        V(apple);
    }
}
```

母亲进程需要的操作：

```cpp
mom (){
    while (true){
        准备一个橘子;
        P(plate);
        P(mutex);
        将橘子放入盘子;
        V(mutex);
        V(orange);
    }
}
```

儿子进程需要的操作：

```cpp
son (){
    while (true){
        P(orange);
        P(mutex);
        从盘子中取出橘子;
        V(mutex);
        V(plate);
        吃掉橘子;
    }
}
```

女儿进程需要的操作：

```cpp
daughter (){
    while (true){
        P(apple);
        P(mutex);
        从盘子中取出苹果;
        V(mutex);
        V(plate);
        吃掉苹果;
    }
}
```

其实，在本题中，即使不设置互斥信号量`mutex`，也不会出现多个进程访问盘子的现象：

<img src="https://images.drshw.tech/images/notes/image-20221008232850620.png" alt="image-20221008232850620" style="zoom:50%;" />

原因在于：本题中缓冲区大小为1，在任何时刻，`apple`、`orange`、`plate`三个同步信号量最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区。若缓冲区大小为2，则会产生冲突问题。

#### 总结

<img src="https://images.drshw.tech/images/notes/image-20221008233403292.png" alt="image-20221008233403292" style="zoom:50%;" />

### 2.4.3 吸烟者问题

#### 问题描述

假设一个系统有**三个抽烟者进程**和**一个供应者进程**。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟， 抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，**第一个拥有烟草、第二个拥有纸、第三个拥有胶水**。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，**拥有剩下那种材料的抽烟者卷一根烟并抽掉它**， 并给**供应者进程一个信号表示抽烟过程完成了**，供应者就会在桌上放另外两种材料，这个过程一直重复（**让三个抽烟者轮流地抽烟**）。请用PV操作实现上述过程。

#### 分析步骤

本质上这题也属于“生产者-消费者”问题，更详细的说应该是“可生产多种产品的单生产者-多消费者问题”。

将问题抽象化：

桌子可以抽象为容量为1的缓冲区，要互斥访问。可以将抽烟者需要的材料分组：

+ 组合一：纸+胶水；
+ 组合二：烟草+胶水；
+ 组合三：烟草+纸。

关系分析：

+ 互斥关系：缓冲区的访问需要互斥进行；（由于本题缓冲区大小为1，互斥信号量也可以不设置，原因在上题中有讲）

+ 同步关系：

  1. 桌上有组合一 -> 第一个抽烟者取走东西；

  2. 桌上有组合二 -> 第二个抽烟者取走东西；

  3. 桌上有组合三 -> 第三个抽烟者取走东西；
  4. 发出完成信号 -> 供应者将下一个组合放到桌上。

整理思路并设置信号量：

<img src="https://images.drshw.tech/images/notes/image-20221009154451032.png" alt="image-20221009154451032" style="zoom:50%;" />

#### 代码实现

信号量设置（不设置互斥信号量）：

```cpp
semaphore offer1 = 0;		// 桌上组合一的数量
semaphore offer2 = 0;		// 桌上组合二的数量
semaphore offer3 = 0;		// 桌上组合三的数量
semaphore finish = 0;		// 抽烟是否完成
int i = 0;			// 用于实现三个抽烟者轮流抽烟
```

供应者进程需要的操作：

```cpp
provider (){
    while(true){
        if(i == 0) {
            将组合一放桌上;
            V(offer1);
        } else if(i == 1){
            将组合二放桌上;
            V(offer2);
        } else if(i == 2){
            将组合三放桌上;
            V(offer3);
        }
        i = (i + 1) % 3;
        P(finish);
    }
}
```

吸烟者1进程需要的操作：

```cpp
smoker1 (){
    while(true){
        P(offer1);
        从桌上拿走组合一; 卷烟; 抽掉;
        V(finish);
    }
}
```

吸烟者2进程需要的操作：

```cpp
smoker2 (){
    while(true){
        P(offer2);
        从桌上拿走组合二; 卷烟; 抽掉;
        V(finish);
    }
}
```

吸烟者3进程需要的操作：

```cpp
smoker3 (){
    while(true){
        P(offer3);
        从桌上拿走组合三; 卷烟; 抽掉;
        V(finish);
    }
}
```

即可实现。

#### 总结

![image-20221009160456897](https://images.drshw.tech/images/notes/image-20221009160456897.png)

![image-20221009160509130](https://images.drshw.tech/images/notes/image-20221009160509130.png)

### 2.4.4 读者-写者问题

#### 问题描述

有读者和写者两组并发进程，共享一个文件，当两个以上的读进程同时访问共享数据时**不会产生副作用**，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：

1. 允许多个读者同时对文件执行读操作；
2. 只允许一个写者往文件中写信息；
3. 任一写者在完成写操作之前不允许其他读者或写者工作；
4. 写者执行完写操作前，应让已有的读者或写者全部退出。

请用PV操作实现上述过程。

#### 分析步骤

1. 关系分析：

   + 两类进程：读进程，写进程；
   + 互斥关系：写进程——写进程；写进程——读进程。读进程与读进程不存在互斥关系；

2. 整理思路：

   写者进程与任何进程都互斥，设置一个互斥信号量`rw`，在写者访问共享文件前后分别执行`P`、`V` 操作；

   读者进程和写者进程也要互斥，因此读者访问共享文件前后也要对`rw`实现`P`、`V`操作；

   但是如果所有读者进程在访问共享文件都执行`P(rw)`操作，那么**会导致各个读进程之间也无法同时访问文件**，怎么解决这个问题呢？

   `P(rw)`和`V(rw)`其实就是对共享文件的“加锁”和“解锁”。既然各个读进程需要同时访问，而读进程与写进程又必须互斥访问，那么我们可以让第一个访问文件的读进程“加锁”，让最后一个访问完的文件读进程“解锁”。可以信号量设置：

   需要设置三个互斥信号量：

   + 第一个互斥信号量为`rw`；
   + 第二个互斥信号量`mutex`，旨在使各读进程互斥地访问`count`变量；
   + 加入了`mutex`后，又会存在一个问题——尽管可以实现多个写进程同时读文件，但是当源源不断的读进程进入时，写进程就需要一直阻塞等待（发生“饥饿”）。因此需要实现“写优先”，即引入一个互斥变量`w`来实现。


#### 代码实现

信号量设置：

```cpp
semaphore rw = 1;	// 用于实现对几个文件的互斥访问
semaphore mutex = 1;	// 用于保证对count变量的互斥访问
semaphore w = 1;	// 用于实现“写优先”
int count = 0;		// 记录当前有几个读进程在访问文件
```

写者进程需要的操作：

```cpp
writer (){
    while(true){
        P(w);		// 实现写优先，放止读进程“饥饿”
        P(rw);		// 写之前“加锁”
        写文件操作;
        V(rw);		// 写之后“解锁”
        V(w);
    }
}
```

读者进程需要的操作：

```cpp
reader (){
    while(true){
        P(w);		// 实现写优先，放止读进程“饥饿”
        P(mutex);	// 各读进程互斥访问count（若缺少该步骤，会存在多个并发的写操作先后执行P(rw)，导致第二个及之后的读进程被阻塞的情况）
        if(count == 0)
            P(rw);	// 第一个读进程负责“加锁”
        count ++;
        V(mutex);
        V(w);
        读文件操作;
        P(mutex);	// 各读进程互斥访问count
        count --;	// 访问文件的读进程数-1
        if(count == 0)
            V(rw);	//在最后一个读进程负责“解锁”
        V(mutex);
    }
}
```

即可实现。

<img src="https://images.drshw.tech/images/notes/image-20221009170047322.png" alt="image-20221009170047322" style="zoom:60%;" />

#### 总结

<img src="https://images.drshw.tech/images/notes/image-20221009170214597.png" alt="image-20221009170214597" style="zoom:60%;" />

### 2.4.5 哲学家进餐问题

#### 问题描述

一张圆桌上坐着5名哲学家，每两个哲学家之间的桌子上摆着**一根筷子**，桌子的中间是一碗米饭。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响其他人。只有当哲学家饥饿的时候，才试图拿起左右两根筷子（一根一根地拿起）。如果筷子已经在他人手上，则需等待。饥饿的哲学家只有同时拿起了两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。

请用PV操作实现上述过程。

#### 分析步骤

1. 关系分析：

   系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。

2. 整理思路：

   这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何**避免**临界资源分配不当造成的**死锁现象**，是哲学家问题的精髓。

3. 信号量设置：

   定义互斥信号量数组`chopstick[5] = {1, 1, 1, 1, 1}`用于实现对5根筷子的互斥访问。并对哲学家按`0~4`编号，哲学家`i`左边的筷子编号为`i`，右边的筷子编号为`(i + 1) % 5`。

#### 代码实现

按照说明的逻辑，可以这样做：

```cpp
semaphore chopstick[5] = {1, 1, 1, 1, 1};// 信号量设置
Pi (){		// 第i个进程需要执行的代码
    while(true){
        P(chopstick[i]);		// 拿左
        P(chopstick[(i + 1) % 5]);	// 拿右
        吃饭;
        V(chopstick[i]);		// 放左
        V(chopstick[(i + 1) % 5]);	// 放右
        思考;
    }
}
```

但是这将导致一个问题——如果5个哲学家并发地拿起了自己左手边的筷子，每位哲学家循环等待右边的人放下筷子（阻塞），将会导致“死锁”。

以下的几个方式可以防止死锁现象：

1. 可以对哲学家进程施加一些限制，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。

2. 或要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。
3. 仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。

方式一实现：

设置一个信号量`count`来记录当前有几个哲学家想吃饭：

```cpp
semaphore chopstick[5] = {1, 1, 1, 1, 1};// 信号量设置
semaphore count = 4;		// 最多四个哲学家同时吃饭
Pi (){		// 第i个进程需要执行的代码
    while(true){
        P(count);			// 请求进入房间进餐，当count为0时，则不能允许哲学家进来了
        P(chopstick[i]);		// 拿左
        P(chopstick[(i + 1) % 5]);	// 拿右
        吃饭;
        V(chopstick[i]);		// 放左
        V(chopstick[(i + 1) % 5]);	// 放右
        V(count);			// 离开饭桌，释放信号量
        思考;
    }
}
```

方式二实现：

加一个奇偶判断即可：

```cpp
semaphore chopstick[5] = {1, 1, 1, 1, 1};// 信号量设置
Pi (){		// 第i个进程需要执行的代码
    while(true){
        if(i % 2 == 0){
            P(chopstick[(i + 1) % 5]);		// 先拿右
            P(chopstick[i]);			// 后拿左
            吃饭;
            V(chopstick[(i + 1) % 5]);		// 先放右
            V(chopstick[i]);			// 后放左
        } else {
            P(chopstick[i]);			// 先拿左
            P(chopstick[(i + 1) % 5]);		// 后拿右
            吃饭;
            V(chopstick[i]);			// 先放左
            V(chopstick[(i + 1) % 5]);		// 后放右
        }
        思考;
    }
}
```

方式三实现：

加入一个互斥信号量`mutex`，保证哲学家互斥地拿筷子：

```cpp
semaphore chopstick[5] = {1, 1, 1, 1, 1};	// 信号量设置
semaphore mutex = 1;		// 互斥的取筷子
Pi (){		// 第i个进程需要执行的代码
    while(true){
        P(mutex);
        P(chopstick[i]);		// 拿左
        P(chopstick[(i + 1) % 5]);	// 拿右
        V(mutex);
        吃饭;
        V(chopstick[i]);		// 放左
        V(chopstick[(i + 1) % 5]);	// 放右
        思考;
    }
}
```

#### 总结

![image-20221009230946239](https://images.drshw.tech/images/notes/image-20221009230946239.png)
