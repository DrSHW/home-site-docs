---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 2.2 进程的同步

### 2.2.1 进程同步与进程互斥

#### 什么是进程同步

在之前的小节中我们了解到，进程具有**异步性**的特征，即意味着各进程以各自独立的、不可预知的速度向前推进。

但是有些情况下，进程必须要保持一定的先后次序执行（例如写数据和读数据是并发执行的，但是必须是先写数据后读数据），于是操作系统就需要“**进程同步**机制”来实现这样的需求。

**同步**亦称**直接制约关系**，它是为完成某种任务而建立的两个或多个进程。这些进程因为需要在某些位置上**协调**他们的**工作次序**而等待、传递信息所产生的制约关系。进程间的直接制约关系就是它们之间的相互合作。

#### 什么是进程互斥

进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源（比如内存，又比如打印机、摄像头之类的I/O设备）。这种资源在**一个时间段内只允许一个进程访问**，对应了[操作系统的两种资源共享方式](https://docs.drshw.tech/os/1/2/#122-%E5%85%B1%E4%BA%AB)中的互斥共享方式。

我们把**一个时间段内只允许一个进程使用**的资源称为**临界资源**。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。

对这些临界资源的访问，必须**互斥**地进行。互斥，亦称**间接制约关系**。**进程互斥**指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问该临界资源。

对临界资源的互斥访问，可以在逻辑上分为**进入区、临界区、退出区**、剩余区四个部分：

```cpp
do {
    entry section;		// 进入区
    critical section;		// 临界区
    exit section;		// 退出区
    remainder section;		// 剩余区
} while(true)
```

+ 进入区：

  负责检测是否可以进入临界区；若可进入，则应**设置正在访问临界资源的标志**（可理解为“上锁”），以阻止其他进程同时进入临界区。

+ 临界区：

  进程中访问临界资源的那段代码（如：执行内存写操作）。

+ 退出区：

  负责**解除正在访问临界资源的标志**（可理解为“解锁”）。

+ 剩余区：

  做其他处理，代码中的剩余部分。

> 注：
>
> **临界区**是进程中**访问临界资源**的代码段，也可称为临界段。
>
> **进入区**和**退出区**是**负责实现互斥**的代码段。

为了实现对临界资源的互斥访问，同时保证系统的整体性能，需要遵循以下原则：

1. **空闲让进**。当临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；
2. **忙则等待**。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；
3. **有限等待**。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；
4. **让权等待**。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待，

### 2.2.2 进程互斥的软件实现方法

进程互斥有以下四种软件实现方法：

<img src="C:\Users\17100\AppData\Roaming\Typora\typora-user-images\image-20221007235021634.png" alt="image-20221007235021634" style="zoom:50%;" />

#### 单标志法

算法思想：两个进程在***访问完临界区后***会把使用临界区的权限转交给另一个进程。也就是说**每个进程进入临界区的权限只能被另一个进程赋予**。

算法流程：

需要先在全局定义一个变量`turn`，表示当前进入临界区的进程号：

```c++
int turn = 0;	// turn 表示当前进入临界区的进程号
```

`turn`的初值为`0`，即刚开始只允许`0`号进程进入临界区。

假设有两个进程`P0`和`P1`，它们的进程号分别为`0`和`1`，应用该算法可以这么实现它们：

```cpp
// P0 进程
while (turn != 0);		// I 进入区
critical section;		// II 临界区
turn = 1;			// III 退出区
remainder section;		// IV 剩余区
```

```cpp
// P1 进程
while (turn != 1);		// V 进入区
critical section;		// VI 临界区
turn = 0;			// VII 退出区
remainder section;		// VIII 剩余区
```

若`P1`现上处理机运行，则会一直卡在代码`V`处。直到`P1`的时间片用完，发生调度，切换到`P0`上处理机运行。

代码`I`不会卡住`P0`，`P0`可以正常访问临界区；在`P0`访问临界区期间即使切换回`P1`，`P1`依然会卡在代码`V`处。

只有`P0`在退出区将`turn`改为`1`后，`P1`才能进入临界区。

因此，该算法可以实现：**同一时刻最多只允许一个进程访问临界区**。

![image-20221007220416206](C:\Users\17100\AppData\Roaming\Typora\typora-user-images\image-20221007220416206.png)

因此，**单标志法**存在的**主要问题**是：**违背“空闲让进”原则**。

#### 双标志先检查法

算法思想：先设置一个布尔型的数组`flag[]`，数组中各元素用来**标记各进程想进入临界区的意愿**，比如 `flag[0]=true` 意味着`0`号进程`P0`现在想要进入临界区。每个进程在进入临界区之前，先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志`flag[i]`设为`true`，之后开始访问临界区。

算法流程：

若有两个进程`P0`、`P1`可能进入临界区，于是需要开辟一个长度为2的全局布尔数组，表示进入临界区意愿的数组；刚开始时设置为两个进程都不想进入临界区：

```cpp
bool flag[2];			// 表示进入临界区意愿的数组
flag[0] = false;
flag[1] = false;		// 刚开始时设置为两个进程都不想进入临界区
```

可以这样实现进程`P0`、`P1`：

```cpp
// P0 进程
while (flag[1]);		// I 如果此时P1想要进入临界区，P0就一直循环等待
flag[0] = true			// II 标记为P0进程想要进入临界区 
critical section;		// III 访问临界区
flag[0] = true			// IV 访问完临界区，修改标记为 P0不想使用临界区
remainder section;		
```

```cpp
// P1 进程
while (flag[0]);		// V 如果此时P0想要进入临界区，P1就一直循环等待
flag[1] = true			// VI 标记为P1进程想要进入临界区 
critical section;		// VII 访问临界区
flag[1] = true			// VIII 访问完临界区，修改标记为 P1不想使用临界区
remainder section;	
```

看似很完美地解决了问题，但是`P0`和`P1`是并发执行的。这就意味着代码`I`与代码`V`可能会同时执行，由于一开始`flag[0]`和`flag[1]`都是`false`，于是它们都会跳出循环，同时访问临界区。

因此，双标志先检验法的**主要问题**是：**违反了“忙则等待”原则**。

原因在于，**进入区**的“检查”和“上锁”**两个处理不是一气呵成的**。“检查”后，“上锁”前可能发生进程切换。

#### 双标志后检查法

算法思想：双标志先检查法的改版。上一个算法由于存在先“检查”后“上锁”无法一次性执行完的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。

算法流程：

还是先定义那个`flag`全局布尔数组，不解释：

```cpp
bool flag[2];			// 表示进入临界区意愿的数组
flag[0] = false;
flag[1] = false;		// 刚开始时设置为两个进程都不想进入临界区
```

然后实现进程`P0`、`P1`，将双标志先检查法中的“上锁”和“检验”的过程互换即可：

```cpp
// P0 进程
flag[0] = true			// I 标记为P0进程想要进入临界区 
while (flag[1]);		// II 如果此时P1想要进入临界区，P0就一直循环等待
critical section;		// III 访问临界区
flag[0] = true			// IV 访问完临界区，修改标记为 P0不想使用临界区
remainder section;		
```

```cpp
// P1 进程
flag[1] = true			// V 标记为P1进程想要进入临界区 
while (flag[0]);		// VI 如果此时P0想要进入临界区，P1就一直循环等待
critical section;		// VII 访问临界区
flag[1] = true			// VIII 访问完临界区，修改标记为 P1不想使用临界区
remainder section;	
```

但是依然存在同样的问题——由于`P0`和`P1`是并发执行的，这就意味着代码`I`与代码`V`可能会同时执行，`flag`数组会被同时置为`true`，这样`P0`和`P1`都无法进入临界区。

因此，双标志后检查法虽然**解决了“忙则等待”**的问题，但是**又违背了“空闲让进”和“有限等待”原则**，会因各进程都长期无法访问临界资源而**产生“饥饿”**现象。

#### Peterson 算法

算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L. Peterson 想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。

算法流程：

需要定义一个全局变量`turn`，代表进程号，该进程会优先进入临界区；还需要一个全局布尔数组，表示进入临界区意愿的数组，初始值都是`false`：

```cpp
bool flag[2] = {false, false};		// 表示进入临界区意愿的数组，初始值都是 false
int turn = 0;				// turn 表示优先让哪个进程进入临界区
```

可以这样实现进程`P0`、`P1`：

```cpp
// P0 进程
flag[0] = true;				// I 表示自己想进入临界区
turn = 1;				// II 可以优先让对方进入临界区
while (flag[1] && turn == 1);	// III 对方想进，且最后一次自己是自己将访问机会让给其他进程的，那自己就循环等待
critical section;			// IV访问临界区
flag[0] = false;			// V 访问完临界区，表示自己已经不想访问临界区了
remainder section;
```

```cpp
// P1 进程 (注释同上)
flag[1] = true;				// VI
turn = 0;				// VII
while (flag[0] && turn == 0);		// VIII
critical section;			// IX
flag[1] = false;			// X
remainder section;
```

进入区为代码`I`、`II`、`III`和`VI`、`VII`、`VIII`。按照该算法，无论是按序执行还是同时进入，都不会产生冲突。

考虑进程`P0`，一旦它设置`flag[0]=true`，则P1不能进入临界区。如果`P1`已经进入临界区，那么`flag[1]=true`，`P0`被阻塞不能进入临界区。

另一方面，互相阻塞也避免了。假设`P0`在`while`里被阻塞了，表示`flag[1]`为`true`且`turn=1`，则此时`P1`可以执行。

Peterson 算法用软件方法解决了进程互斥问题，**遵循了空闲让进、忙则等待、有限等待三个原则**，但是依然**未遵循让权等待**原则。相较于之前三种软件解决方案来说，它是最好的，但还是不够好。

### 2.2.3 进程互斥的硬件实现方法

进程互斥有以下三种硬件实现方法：

<img src="C:\Users\17100\AppData\Roaming\Typora\typora-user-images\image-20221007234950656.png" alt="image-20221007234950656" style="zoom:50%;" />

#### 中断屏蔽方法

即利用“**开/关中断指令**”实现，在临界区执行前进行关中断，执行完临界区后进行开中断（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两进程同时访问临界区的情况）：

<img src="C:\Users\17100\AppData\Roaming\Typora\typora-user-images\image-20221007230806837.png" alt="image-20221007230806837" style="zoom:50%;" />

优点：简单、高效；

缺点：

+ 不适用于多处理机（执行关中断只对执行关中断的处理机有效，对其他处理机无效）；
+ 只适用于操作系统的内核进程，不适用于用户进程（因为开/关中断运行在内核态）。

#### TestAndSet 指令

简称`TS`指令，该指令时**由硬件实现**，执行的过程中不允许被中断，只能一气呵成。

可以使用C语言函数描述`TestAndSet`的逻辑：

```cpp
// 布尔共享型变量 lock 表示当前临界区是否被加锁
// true表示已加锁，false表示未加锁
bool TestAndSet (bool *lock){
    bool old;
    old = *lock;		// old用来存放lock原来的值
    *lock = true;		// 无论之前是否加锁，都将lock设置为true
    return old;			// 返回lock原来的值
}
```

描述使用`TS`指令实现互斥的逻辑：

```cpp
while (TestAndSet (&lock));		// 上锁并检查
critical section;			// 临界区代码段
lock = false;				// 解锁
remainder section;			// 剩余区代码段
```

+ 若刚开始`lock`为`false`，则`TS`返回的`old`值为`false`，`while`循环条件不满足，直接跳过循环，进入临界区；
+ 若放开始`lock`为`true`，则执行`TS`后`old`返回的值为`true`，`while`循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。

相比软件实现方法，`TS`指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。

优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境；

缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行`TS`指令，从而导致“忙等”。

#### Swap 指令

`Swap`指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。

可以使用C语言函数描述`Swap`的逻辑（即交换两个变量的值）：

```cpp
// Swap 指令的作用是交换两个变量的值
Swap (bool *a, bool *b) {
    bool temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
```

描述使用`Swap`指令实现互斥的逻辑：

```cpp
bool old = true;
while (old == true)
    Swap(&lock, &old);
critical section;			// 临界区代码段
lock = false;				// 解锁
remainder section;			// 剩余区代码段
```

逻辑上来看`Swap`和`TS`并无太大区别，都是记录下此时临界区是否已经被上锁（记录在`old`变量上），再将上锁标记`lock`设置为`true`；最后检查`old`，如果`old`为`false`则说明之前没有其他进程对临界区上锁，则可跳出循环，进入临界区。

优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境；

缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。

### 2.2.4 信号量机制

它是一个整数值，用于传递信息。

一个进程在某一特殊点上被迫停止，直到收到特殊变量值，这个变量值是信号量

按用途分类：

* 整形信号量:表示资源数目

* 记录型信号量：记录型数据结构

信号量上面三个操作;

初始化、P(s)/wait(s) 和 V(s)/signal(s)

P:申请资源；V：释放资源；

初始化：开始的时候定义有多少资源量

### 2.2.5 使用信号量机制实现 进程互斥、同步、前驱关系

整形信号量例如：

```c
int S = 1; // 初始化
void wait(S){
  while (S<=0); // 没有资源的时候堵住
  S--;
}
```

```js
wait(S) //进入区 
// 使用打印机资源，临界区
signal(S) // 退出区
```

通过信号量机制可以避免同步和并发导致的问题，因为检查和上锁的机制

产生的问题：忙等

记录型信号量：

解决忙等。把信号量设计为数据结构，如

```c
typedef struct {
  int value;
  struct process List ; //等待队列
} semaphore
```

申请资源

```c
void P(semaphore S){
  S.value--;
  if(S.value<0){
    block(S.L) /
    // 如果资源小于0，把自己放进阻塞队列
  }
}
```

释放

```c
void P(semaphore S){ // 释放一个资源
  S.value++;
  if(S.value<0){
    wakeup(S.L) // 其实就是去拉起队列里的进程
  }
}

```
S>0的时候，表示资源的个数

S<0, 表示等待队列里面的进程数目

信号量机制实现：进程互斥

对于并发进程的关键操作，需要划定临界区

需要有一个互斥信号量mutex=1

  ```c
  int mutex = 1;
  P1(){
    P(mutex); // 加锁
    // 临界区代码
    V(mutex); // 释放锁
  }
  ```

 进程同步：

让异步并发的进程，要处理好执行的次序

对于一个资源，

前操作需要V操作

后操作需要P操作