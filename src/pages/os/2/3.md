---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 2.3 进程同步

### 2.3.1 进程同步与进程互斥

#### 什么是进程同步

在之前的小节中我们了解到，进程具有[**异步性**](https://docs.drshw.tech/os/2/1/#%E7%89%B9%E5%BE%81)的特征，即意味着各进程以各自独立的、不可预知的速度向前推进。

但是有些情况下，进程必须要保持一定的先后次序执行（例如写数据和读数据是并发执行的，但是必须是先写数据后读数据），于是操作系统就需要“**进程同步**机制”来实现这样的需求。

**同步**亦称**直接制约关系**，它是为完成某种任务而建立的两个或多个进程。这些进程因为需要在某些位置上**协调**他们的**工作次序**而等待、传递信息所产生的制约关系。进程间的直接制约关系就是它们之间的相互合作。

#### 什么是进程互斥

进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源（比如内存，又比如打印机、摄像头之类的I/O设备）。这种资源在**一个时间段内只允许一个进程访问**，对应了[操作系统的两种资源共享方式](https://docs.drshw.tech/os/1/2/#122-%E5%85%B1%E4%BA%AB)中的互斥共享方式。

我们把**一个时间段内只允许一个进程使用**的资源称为**临界资源**。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。

对这些临界资源的访问，必须**互斥**地进行。互斥，亦称**间接制约关系**。**进程互斥**指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问该临界资源。

对临界资源的互斥访问，可以在逻辑上分为**进入区、临界区、退出区**、剩余区四个部分：

```cpp
do {
    entry section;	// 进入区
    critical section;	// 临界区
    exit section;	// 退出区
    remainder section;	// 剩余区
} while(true)
```

+ 进入区：

  负责检测是否可以进入临界区；若可进入，则应**设置正在访问临界资源的标志**（可理解为“上锁”），以阻止其他进程同时进入临界区。

+ 临界区：

  进程中访问临界资源的那段代码（如：执行内存写操作）。

+ 退出区：

  负责**解除正在访问临界资源的标志**（可理解为“解锁”）。

+ 剩余区：

  做其他处理，代码中的剩余部分。

> 注：
>
> **临界区**是进程中**访问临界资源**的代码段，也可称为临界段。应尽量减少进程访问临界区的时间，尽量将一些非必要的代码放入剩余区。
>
> **进入区**和**退出区**是**负责实现互斥**的代码段。

为了实现对临界资源的互斥访问，同时保证系统的整体性能，需要遵循以下原则：

1. **空闲让进**。当临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；
2. **忙则等待**。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；
3. **有限等待**。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会**饥饿**，即某进程/作业**长期得不到服务**）；
4. **让权等待**。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待，

<img src="https://images.drshw.tech/images/notes/image-20221101224409820.png" alt="image-20221101224409820" style="zoom:50%;" />

### 2.3.2 进程互斥的软件实现方法

进程互斥有以下四种软件实现方法：

<img src="https://images.drshw.tech/images/notes/image-20221007235021634.png" alt="image-20221007235021634" style="zoom:50%;" />

#### 单标志法

算法思想：两个进程在***访问完临界区后***会把使用临界区的权限转交给另一个进程。也就是说**每个进程进入临界区的权限只能被另一个进程赋予**。

算法流程：

需要先在全局定义一个变量`turn`，表示当前进入临界区的进程号：

```cpp
int turn = 0;	// turn 表示当前进入临界区的进程号
```

`turn`的初值为`0`，即刚开始只允许`0`号进程进入临界区。

假设有两个进程`P0`和`P1`，它们的进程号分别为`0`和`1`，应用该算法可以这么实现它们：

```cpp
// P0 进程
while (turn != 0);	// I 进入区
critical section;	// II 临界区
turn = 1;		// III 退出区
remainder section;	// IV 剩余区
```

```cpp
// P1 进程
while (turn != 1);	// V 进入区
critical section;	// VI 临界区
turn = 0;		// VII 退出区
remainder section;	// VIII 剩余区
```

若`P1`现上处理机运行，则会一直卡在代码`V`处。直到`P1`的时间片用完，发生调度，切换到`P0`上处理机运行。

代码`I`不会卡住`P0`，`P0`可以正常访问临界区；在`P0`访问临界区期间即使切换回`P1`，`P1`依然会卡在代码`V`处。

只有`P0`在退出区将`turn`改为`1`后，`P1`才能进入临界区。

因此，该算法可以实现：**同一时刻最多只允许一个进程访问临界区**。

![image-20221007220416206](https://images.drshw.tech/images/notes/image-20221007220416206.png)

因此，**单标志法**存在的**主要问题**是：**违背“空闲让进”原则**。

#### 双标志先检查法

算法思想：先设置一个布尔型的数组`flag[]`，数组中各元素用来**标记各进程想进入临界区的意愿**，比如 `flag[0]=true` 意味着`0`号进程`P0`现在想要进入临界区。每个进程在进入临界区之前，先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志`flag[i]`设为`true`，之后开始访问临界区。

算法流程：

若有两个进程`P0`、`P1`可能进入临界区，于是需要开辟一个长度为2的全局布尔数组，表示进入临界区意愿的数组；刚开始时设置为两个进程都不想进入临界区：

```cpp
bool flag[2];		// 表示进入临界区意愿的数组
flag[0] = false;
flag[1] = false;	// 刚开始时设置为两个进程都不想进入临界区
```

可以这样实现进程`P0`、`P1`：

```cpp
// P0 进程
while (flag[1]);	// I 如果此时P1想要进入临界区，P0就一直循环等待
flag[0] = true		// II 标记为P0进程想要进入临界区 
critical section;	// III 访问临界区
flag[0] = true		// IV 访问完临界区，修改标记为 P0不想使用临界区
remainder section;		
```

```cpp
// P1 进程
while (flag[0]);	// V 如果此时P0想要进入临界区，P1就一直循环等待
flag[1] = true		// VI 标记为P1进程想要进入临界区 
critical section;	// VII 访问临界区
flag[1] = true		// VIII 访问完临界区，修改标记为 P1不想使用临界区
remainder section;	
```

看似很完美地解决了问题，但是`P0`和`P1`是并发执行的。这就意味着代码`I`与代码`V`可能会同时执行，由于一开始`flag[0]`和`flag[1]`都是`false`，于是它们都会跳出循环，同时访问临界区。

因此，双标志先检验法的**主要问题**是：**违反了“忙则等待”原则**。

原因在于，**进入区**的“检查”和“上锁”**两个处理不是一气呵成的**。“检查”后，“上锁”前可能发生进程切换。

#### 双标志后检查法

算法思想：双标志先检查法的改版。上一个算法由于存在先“检查”后“上锁”无法一次性执行完的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。

算法流程：

还是先定义那个`flag`全局布尔数组，不解释：

```cpp
bool flag[2];		// 表示进入临界区意愿的数组
flag[0] = false;
flag[1] = false;	// 刚开始时设置为两个进程都不想进入临界区
```

然后实现进程`P0`、`P1`，将双标志先检查法中的“上锁”和“检验”的过程互换即可：

```cpp
// P0 进程
flag[0] = true		// I 标记为P0进程想要进入临界区 
while (flag[1]);	// II 如果此时P1想要进入临界区，P0就一直循环等待
critical section;	// III 访问临界区
flag[0] = true		// IV 访问完临界区，修改标记为 P0不想使用临界区
remainder section;		
```

```cpp
// P1 进程
flag[1] = true		// V 标记为P1进程想要进入临界区 
while (flag[0]);	// VI 如果此时P0想要进入临界区，P1就一直循环等待
critical section;	// VII 访问临界区
flag[1] = true		// VIII 访问完临界区，修改标记为 P1不想使用临界区
remainder section;	
```

但是依然存在同样的问题——由于`P0`和`P1`是并发执行的，这就意味着代码`I`与代码`V`可能会同时执行，`flag`数组会被同时置为`true`，这样`P0`和`P1`都无法进入临界区。

因此，双标志后检查法虽然**解决了“忙则等待”**的问题，但是**又违背了“空闲让进”和“有限等待”原则**，会因各进程都长期无法访问临界资源而**产生“饥饿”**现象。

#### Peterson 算法

算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L. Peterson 想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。

算法流程：

需要定义一个全局变量`turn`，代表进程号，该进程会优先进入临界区；还需要一个全局布尔数组，表示进入临界区意愿的数组，初始值都是`false`：

```cpp
bool flag[2] = {false, false};	// 表示进入临界区意愿的数组，初始值都是 false
int turn = 0;			// turn 表示优先让哪个进程进入临界区
```

可以这样实现进程`P0`、`P1`：

```cpp
// P0 进程
flag[0] = true;		// I 表示自己想进入临界区
turn = 1;		// II 可以优先让对方进入临界区
while (flag[1] && turn == 1); // III 对方想进，且最后一次自己是自己将访问机会让给其他进程的，那自己就循环等待
critical section;	// IV访问临界区
flag[0] = false;	// V 访问完临界区，表示自己已经不想访问临界区了
remainder section;
```

```cpp
// P1 进程 (注释同上)
flag[1] = true;			// VI
turn = 0;			// VII
while (flag[0] && turn == 0);	// VIII
critical section;		// IX
flag[1] = false;		// X
remainder section;
```

进入区为代码`I`、`II`、`III`和`VI`、`VII`、`VIII`。按照该算法，无论是按序执行还是同时进入，都不会产生冲突。

考虑进程`P0`，一旦它设置`flag[0]=true`，则P1不能进入临界区。如果`P1`已经进入临界区，那么`flag[1]=true`，`P0`被阻塞不能进入临界区。

另一方面，互相阻塞也避免了。假设`P0`在`while`里被阻塞了，表示`flag[1]`为`true`且`turn=1`，则此时`P1`可以执行。

Peterson 算法用软件方法解决了进程互斥问题，**遵循了空闲让进、忙则等待、有限等待三个原则**，但是依然**未遵循让权等待**原则。相较于之前三种软件解决方案来说，它是最好的，但还是不够好。

### 2.3.3 进程互斥的硬件实现方法

进程互斥有以下三种硬件实现方法：

<img src="https://images.drshw.tech/images/notes/image-20221007234950656.png" alt="image-20221007234950656" style="zoom:50%;" />

#### 中断屏蔽方法

即利用“**开/关中断指令**”实现，在临界区执行前进行关中断，执行完临界区后进行开中断（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两进程同时访问临界区的情况）：

<img src="https://images.drshw.tech/images/notes/image-20221007230806837.png" alt="image-20221007230806837" style="zoom:50%;" />

优点：简单、高效；

缺点：

+ 不适用于多处理机（执行关中断只对执行关中断的处理机有效，对其他处理机无效）；
+ 只适用于操作系统的内核进程，不适用于用户进程（因为开/关中断运行在内核态）。

#### TestAndSet 指令

简称`TS`指令，该指令时**由硬件实现**，执行的过程中不允许被中断，只能一气呵成。

可以使用C语言函数描述`TestAndSet`的逻辑：

```cpp
// 布尔共享型变量 lock 表示当前临界区是否被加锁
// true表示已加锁，false表示未加锁
bool TestAndSet (bool *lock){
    bool old;
    old = *lock;	// old用来存放lock原来的值
    *lock = true;	// 无论之前是否加锁，都将lock设置为true
    return old;		// 返回lock原来的值
}
```

描述使用`TS`指令实现互斥的逻辑：

```cpp
while (TestAndSet (&lock));	// 上锁并检查
critical section;		// 临界区代码段
lock = false;			// 解锁
remainder section;		// 剩余区代码段
```

+ 若刚开始`lock`为`false`，则`TS`返回的`old`值为`false`，`while`循环条件不满足，直接跳过循环，进入临界区；
+ 若放开始`lock`为`true`，则执行`TS`后`old`返回的值为`true`，`while`循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。

相比软件实现方法，`TS`指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。

优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境；

缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行`TS`指令，从而导致“忙等”。

#### Swap 指令

`Swap`指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。

可以使用C语言函数描述`Swap`的逻辑（即交换两个变量的值）：

```cpp
// Swap 指令的作用是交换两个变量的值
Swap (bool *a, bool *b) {
    bool temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
```

描述使用`Swap`指令实现互斥的逻辑：

```cpp
bool old = true;
while (old == true)
    Swap(&lock, &old);
critical section;		// 临界区代码段
lock = false;			// 解锁
remainder section;		// 剩余区代码段
```

逻辑上来看`Swap`和`TS`并无太大区别，都是记录下此时临界区是否已经被上锁（记录在`old`变量上），再将上锁标记`lock`设置为`true`；最后检查`old`，如果`old`为`false`则说明之前没有其他进程对临界区上锁，则可跳出循环，进入临界区。

优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境；

缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。

### 2.3.4 信号量机制

为了解决上节中提到的几个方案的缺陷（所有的方案都无法解决“让权等待”），1995年，荷兰学者 Dijkstra 提出了一种卓有成效的实现进程互斥、同步的方法——**信号量机制**。

用户进程可以通过使用操作系统提供的**一对原语**来对**信号量**进行操作，从而很方便的实现了进程互斥、进程同步。

+ **一对原语**：**`wait(S)`**原语和**`signal(S)`**原语，可以把原语理解为我们自己写的函数，函数名分别为`wait`和`singal`，括号里的**信号量`S`**其实就是函数调用时传入的一个参数；它们**实现了系统资源的“申请”和“释放”**。

  `wait`、`signal`原语常简称为`P`、`V`操作（荷兰语proberen和verhogen）。

+ **信号量**：其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来**表示系统中某种资源的数量**，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。

  按用途分类，可分为整型信号量和记录型信号量：

  <img src="https://images.drshw.tech/images/notes/image-20221008152647564.png" alt="image-20221008152647564" style="zoom:50%;" />

#### 整型信号量

即用一个**整数型的变量**作为信号量，用来**表示系统中某种资源的数量**。

举个例子，某计算机系统中有一台打印机，可以这么定义信号量和`P`、`V`操作：

```cpp
int S = 1; 	// 初始化整型信号量S，表示当前系统中可用的打印机资源数

void wait (int S) {	// wait 原语，相当于“进入区”
    while (S <= 0);	// 若资源数不足，则一直循环等待
    S = S - 1;		// 若资源充足，则占用一个资源
}

void signal (int S) {	// signal 原语，相当于“退出区
    S = S + 1;		// 使用完资源后，在退出区释放资源
}
```

若进程`P`欲使用打印机资源，执行逻辑如下：

```cpp
...
wait(S);		// 进入区，申请资源
critical section;	// 临界区代码段，访问打印机资源
signal(S);		// 退出区，释放
...
```

若一个进程`P0`抢占到了打印机资源，在`P0`的进入区`S`将被置为0；若有其他进程想访问打印机资源，则会被卡在`while`循环处。当`P0`进程访问完毕，会在退出区释放资源，此时`S`的值将被置为1，资源就可以被分配给其它进程。

由于`wait`是使用原语实现的（进程`Pi`若卡在`wait`不退出，其余进程就无法进入`wait`），避免了并发、异步导致的问题。

但是它依然会发生“忙等”（卡在`while`循环占用处理机），不满足“让权等待”。

#### 记录型信号量（本节非常重要）

整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。

某计算机系统中有两台打印机，记录型信号量可描述为：

```cpp
/* 记录型信号量的定义 */
typedef struct {
    int value = 2;		// 剩余资源数，可以进入临界区的“名额”
    struct process *L = null;	// 等待队列
} semaphore;

/* 某进程需要使用资源时，通过wait原语申请 */
void wait (semaphore S) {
    S.value --;
    if (S.value < 0) {
        block(S.L);	// 如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列（即阻塞队列）中
    }
}

/* 进程使用完资源后，通过signal原语释放 */
void signal (semaphore S) {
    S.value ++;
    if (S.value <= 0) {
        wakeup(S.L);	// 释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态
    }
}
```

若进程`P`欲使用打印机资源，执行逻辑如下：

```cpp
...
wait(S);		// 进入区，申请资源
critical section;	// 临界区代码段，访问打印机资源
signal(S);		// 退出区，释放
...
```

说明：

若`P0`、`P1`、`P2`、`P3`依照先后次序想访问打印机资源，流程如下：

先切换到进程`P0`，`S.value`的值变为1，**不小于**0，可直接访问资源，进入临界区；切换到进程`P1`，`S.value`的值变为0，不小于0，也进入临界区。

切换到`P2`进程，此时`S.value`的值变为-1，小于0，被阻塞，会在等待队列`L`中加入进程`P2`；切换到`P3`进程，此时`S.value`的值变为-2，小于0，被阻塞，会在等待队列`L`中再加入进程`P3`；

若`P0`先将打印资源使用完毕，会调用`signal`指令，`S.value`变为 `-1`，**不大于**0，意味着还有进程在等待资源分配；此时将执行`wakeup`原语，唤醒等待队列队头的进程，即`P2`；唤醒后`P2`由[阻塞态](https://docs.drshw.tech/os/2/1/#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81)进入就绪态，打印机分配资源后，进入运行态，访问打印机资源；

若`P2`提前将打印资源使用完毕，`S.value`变为 `0`，等待队列变为空队列，资源恰好分配完；此时会通过`wakeup`唤醒`P3`，`P3`随即访问打印机资源；

接下来`P1`将打印资源使用完毕，`S.value`变为 `1`，大于0，无进程在等待该资源，无需再执行`wakeup`原语。`P3`执行完毕也是同理。

总结：

**`S.value`的初值**表示系统中**某种资源的数目**。

对信号量`S`的**一次`P`操作**意味着进程**请求一个单位的该类资源**，因此需要执行`S.value --`，表示资源数减1，当`S.value < 0`时表示该类资源已分配完毕，因此进程应**调用`block`原语进行自我阻塞**（当前运行的进程从**运行态->阻塞态**），主动放弃处理机，并插入该类资源的等待队列S.L中。可见，该机制**遵循了“让权等待”原则**，不会出现“忙等”现象。

对信号量`S`的**一次`V`操作**意味着进程**释放一个单位的该类资源**，因此需要执行`S.value ++`，表示资源数加1，若加1后仍是`S.value <= 0`，表示依然有进程在等待该类资源，因此应**调用`wakeup`原语唤醒等待队列中的第一个进程**（被唤醒进程从**阻塞态->就绪态**）。

### 2.3.5 使用信号量机制实现 进程互斥、同步、前驱关系

<img src="https://images.drshw.tech/images/notes/image-20221008221317348.png" alt="image-20221008221317348" style="zoom:80%;" />

#### 用信号量机制实现进程互斥

步骤如下：

1. 分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）；
2. 设置**互斥信号量**`mutex`，**初值为1**；
3. 在临界区之前执行`P(mutex)`；
4. 在临界区之后执行`V(mutex)`；

这些步骤可以抽象为下面的代码（注：信号量均使用`semaphore`结构体类型表示）：

  ```c
/* 信号量机制实现互斥 */ 
semaphore mutex = 1;	// 初始化信号量
P1(){
    ...
	P(mutex);	 	// 使用临界资源前需要加锁
	critical section; 	// 临界区代码段
	V(mutex); 		// 使用临界资源后需要解锁
    ...
}
  ```

要注意的是，对于**不同的临界资源**，需要**设置不同的信号量**。

**P、V操作必须成对出现**（一对互斥变量对应一个互斥进程）。缺少`P(mutex)`就不能保证临界资源的互斥访问。缺少`V(mutex)`会导致资源永不被释放，等待进程永不被唤醒。

<img src="https://images.drshw.tech/images/notes/image-20221008214008870.png" alt="image-20221008214008870" style="zoom:50%;" />

#### 信号量机制实现进程同步

步骤如下：

1. 分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）；
2. 设置**同步信号量**`S`，**初始为0**；
3. **在“前操作”之后执行`V(S)`**；
4. **在“后操作”之前执行`P(S)`**；

这里有点抽象，我们举个例子：

若两个进程`P1`、`P2`并发执行，由于存在异步性，因此二者交替推进的次序是不确定的：

```cpp
P1() {
    代码1;
    代码2;
    代码3;
}
P2() {
    代码4;
    代码5;
    代码6;
}
```

若`P2`的“代码4”要基于`P1`的“代码1”和“代码2”的运行结果才能执行，那么我们就必须保证“代码4”一定是在“代码2”之后才会执行，使用信号量机制的逻辑可以这样实现：

```cpp
/* 信号量机制实现同步 */
semaphore S = 0;	// 初始化同步信号量，初始值为0
P1() {
    代码1;
    代码2;
    V(S);		// 代码1和代码2是前操作，之后执行V(S)
    代码3;
}
P2() {
    P(S);		// 代码4是后操作，之前执行P(S)
    代码4;
    代码5;
    代码6;
}
```

说明：

若先执行到`V(S)`操作，则`S++`后`S=1`。之后当执行到`P(S)`操作时，由于`S=1`，表示有可用资源，会执行`S--`，`S`的值变回`0`，`P2`进程不会执行`block`原语，而是继续往下执行代码4。

若先执行到`P(S)`操作，由于`S=0`，`S --`后`S=-1`，表示此时没有可用资源，因此`P`操作中会执行`block`原语，主动请求阻塞。之后当`P1`进程执行完代码2，继而执行`V(S)`操作，`S++`，使`S`变回`0`，由于此时有进程在该信号量对应的阻塞队列中，因此会在`V`操作中执行`wakeup`原语，唤醒`P2`进程。这样`P2`就可以继续执行代码4了。

这样就保证了代码4一定在代码2后执行。

#### 信号量机制实现前驱关系

什么是进程的前驱关系呢？举个例子：

进程`P1`中有句代码`S1`， 以此类推，进程`P6`中有句代码`S6`。以下代码要求按如下前驱图所示的顺序来执行：

<img src="https://images.drshw.tech/images/notes/image-20221008220232622.png" alt="image-20221008220232622" style="zoom:50%;" />

其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作），因此，

1. 要为每一对前驱关系各设置一个同步变量；

   <img src="https://images.drshw.tech/images/notes/image-20221008220710158.png" alt="image-20221008220710158" style="zoom:50%;" />

2. **在“前操作”之后对相应的同步变量执行`V`操作**；

3. **在“后操作”之前对相应的同步变量执行`P`操作**；

   <img src="https://images.drshw.tech/images/notes/image-20221008220844871.png" alt="image-20221008220844871" style="zoom:50%;" />

于是，各进程的代码逻辑如下：

<img src="https://images.drshw.tech/images/notes/image-20221008220858380.png" alt="image-20221008220858380" style="zoom:80%;" />
