---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 本章疑难点

### 课内知识点

#### 为什么程序不能被调度？

因为程序是静态的，程序即使只有一次结果不再现，也是错误的。

要使结果再现，符合并发的要求，需要满足[Berstein条件](https://docs.drshw.tech/os/1/2/#bernstein%E6%9D%A1%E4%BB%B6)，但几乎不可能满足所有指令没有交集，所以一般情况下程序不能并发，也不能被调度。

#### 为什么要引入进程？

因为程序不能被调度；而对于进程，它具有可描述进程的基本情况和运行状态的[PCB](https://docs.drshw.tech/os/2/1/#21-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)，对其进行控制和管理。

#### 进程为什么可以实现并发？

因为有PCB。它是动态的过程，且在任何时候中断，信息都会存储在PCB中，不会存在问题。

#### 如何实现进程控制？

使用[原语](https://docs.drshw.tech/os/2/2/#222-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8E%9F%E8%AF%AD)实现。原语是一种特殊的条件，运行不可中断。

#### 进程控制相关的原语有哪些？

[进程的创建、终止、阻塞、唤醒、切换](https://docs.drshw.tech/os/2/2/#222-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8E%9F%E8%AF%AD)。

#### 原子操作是什么

原子操作执行过程只能一气呵成，中间不允许被中断。一般使用“[关中断指令](https://docs.drshw.tech/os/2/2/#221-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)”和“开中断指令”这两个[特权指令](https://docs.drshw.tech/os/1/4/#141-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6)实现原子性。

### 课上习题

#### 复杂生产者消费者

某银行提供一个窗口和10个供顾客等待的座位。顾客到达银行时，若有空座位，则到取号机上领取一个号，等待叫号；否则等待有空座位产生才能取号。取号机每次仅允许一位顾客使用，当营业员空闲时，通过叫号选取一位顾客，并为其服务。顾客和营业员的活动过程描述如下：

```cpp
cobegin
{
    process 顾客i
    {
        从取号机获取一个号码;
        等待叫号;
    }
    process 营业员
    {
        while (true)
        {
            叫号;
            提供服务;
        }
    }
}coend
```

#### 分析步骤

将问题抽象化：

营业员可看作生产者进程；顾客可看作消费者进程。座位可视为一个大小为10，初始为10的缓冲区。

关系分析：

+ 互斥关系：对取号操作需要互斥地进行；

+ 同步关系（一前一后）：

  1. 当存在空座位时，顾客才能取号；
  2. 仅当所有座位不空时，营业员才能开始服务；
  3. 营业员叫号后，顾客才能获取服务；

代码实现：

```cpp
// 信号量设置
semaphore mutex=1;  //互斥使用取号机
semaphore empty=10; //空座位的数量，设置为10
semaphore full=0;   //已占座位的数量，初值为0
semaphore service=0;    //等待叫号，初始状态下银行一定是做好准备的，故设为1
// 进程操作
cobegin 
{
    process 顾客i
    {
        P(empty);   //等空位
        P(mutex);   //申请使用取号机
        从取号机获取一个号码；
        V(mutex);   //取号完毕
        P(sevice);  //等待营业员叫号
        V(full);    //通知营业员有新顾客
    }
    process 营业员{
        while(true)
        {
            P(full);    //没有顾客则休息
            叫号；
            V(empty);   //顾客离开座位，释放一个空位
            提供服务;
            V(service); //服务
        }
    }
 }coend
```

### 课后习题

#### T7: 试说明PCB的作用具体表现在哪些方面？为什么说PCB是进程存在的唯一标志？

1. PCB是系统中用来存放进程管理和控制信息的数据结构，保存每一个进程和资源的相关信息包括进程标识、空间、运行状态、资源等相关信息。以便于操作系统对进程和资源进行控制；
2. PCB作用是让一个在多道程序环境下不能独立运行的程序（包括程序影响的数据），形成一个能够独立运行的进程。同时提供进程管理、进程调度所需要的信息；实现进程间的同步与通信；
3. 因为在进程的整个生命周期中，PCB记录进程的所有特性信息，系统只通过PCB对进程进行控制。创建一个进程同时创建一个PCB，在撤销一个进程的同时也会回收它的PCB。

#### T10: 何谓操作系统内核？内核的主要功能是什么？

1. 现在的操作系统将OS划分为若干层次，将OS的不同功能分别设置在不同的层次中。通常将一些与硬件紧密相关的模块、各种常用设备的驱动程序和运行频率较高的模块都放在紧靠硬件的软件层次中，让其常驻内存，即OS内核；

2. 主要功能是时钟管理、中断机制、原语、进程管理、存储器管理、设备管理等。

#### T21: 是从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较

1. 调度性。在传统的OS中，拥有资源的基本单位、独立调度和分派的基本单位都是进程。而在引入线程的OS中，则把线程作为调度和分派的基本单位，进程只是拥有资源的基本单位，不再是调度和分派的基本单位；
2. 并发性。传统的OS只有完整的进程间可以并发执行。在引入线程的OS中，不仅进程间可以并发执行，而且在一个进程内的多个线程间也可以并发执行，因此比传统的OS具有更好的并发性；
3. 拥有资源。在这两种OS中，拥有资源的基本单位都是进程。线程除了一点在运行中必不可少的资源（例如线程控制块、程序计数器、一组寄存器值和堆栈）外，本身不拥有系统资源，但它可以共享其隶属进程的所有资源；
4. 系统开销。在创建和撤销进程时，系统都要为其分配和回收资源，如内存空间等。进程切换时所要保存和设置的现场信息要多于线程，因此，OS在创建、撤销和切换进程时所付出的开销远大于线程。此外，因为隶属于同一进程的多个线程共享同一地址空间和打开文件，使线程之间的同步和通信的实现所需开销更少且更加容易。
