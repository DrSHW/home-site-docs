---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 2.5 管程机制

### 引言：为什么要实现管程？

<img src="https://images.drshw.tech/images/notes/image-20221009231516493.png" alt="image-20221009231516493" style="zoom:50%;" />

为了实现程序对一些共享资源的互斥/同步访问，我们引入了管程。

> 基本思想：将分散在各进程中的临界区集中起来管理，并把共享资源用数据结构抽象地表示出来。（类似于面向对象语言中的**类`class`**，**封装思想**）

### 2.5.1 管程的定义和基本特征

管程是一种特殊的软件模块，由以下部分组成：

1. 局部于管程的**共享数据结构**说明；
2. 对该数据结构进行操作的**一组过程**（函数）；
3. 对局部于管程的共享数据设置**初始值**的语句；
4. 管程有一个**名字**。

管程的基本特征：

1. 局部于管程的数据只能被局部于管程的过程所访问；
2. 一个进程只有通过调用管程内过程才能进入管程访问的共享数据；
3. **每次仅允许一个进程在管程内执行某个内部过程。**

### 2.5.2 管程的条件变量

#### 条件变量

**条件变量**是出现在管程内的一种数据结构，用于区别各种不同的等待原因。

条件变量只有在管程中才能被访问，当调用管程过程的进程无法运行时，用于阻塞进程的一种信号量。它对管程内的所有过程是全局的，只能通过两个原语操作来控制它。

#### 等待机制

管程内部由自己的**等待机制**。管程可以说明一种特殊的**条件型变量**：`condition x, y;`：实际上是一个指针，指向一个等待该条件的PCB队列，对条件型变量可执行`x.wait()`和`x.signal()` 操作：

+ `x.wait`：阻塞调用进程并释放管程使用权。执行本操作的进程进入`x`队列；
+ `x.signal`：唤醒`x`队列的第一个等待者。

这里的概念比较抽象，可结合下面的应用实例来看。

### 2.5.3 管程的应用

#### 模拟管程

下面使用C++模拟管程逻辑，实现生产者-消费者问题。

设置**条件变量**和**等待/唤醒操作**，以解决同步问题，代码如下：

```cpp
...

class Monitor
{
    /* 用于实现同步的条件变量 */
    semaphre full = null;	// 表示缓冲区中已有的产品队列
    emptyQueue empty = null; // 表示缓冲区中空闲的位置队列
    /* 辅助变量 */
    int count = 0, size;    // 缓冲区中的产品数和缓冲区大小
    ProducerConsumer(int n)
    {
        size = n;
    }
    void insert(Item item) 	// 将item放入缓冲区
    {
        if (count == size)
            wait(full);
        count ++;
        insert_item(item);
        if (count == 1)
            signal(empty);
    }
    Item remove() 	// 从缓冲区取出一个产品
    {
        if (count == 0)
            wait(empty);
        count --;
        if (count == N - 1)
            signal(full);
        return remove_item();
    }
};

// 实例化管程
Monitor pc(10);

void producer()
{
    while (true)
    {
    	item = produce_item();	// 生产产品item
    	pc.insert(item);
    }
}
// 消费者进程
void consumer()
{
    while (true)
    {
    	item = pc.remove();
    	consume_item(item); 	// 消费产品item
    }
}

...
```

#### 使用Python装饰器实现`synchronized`（拓展）

`synchronized`，即保证程序中的某些方法，**最多仅能有一个进程同时访问**。使用[Python的装饰器](https://docs.drshw.tech/pb/primary/10/#%E8%A3%85%E9%A5%B0%E5%99%A8)可以这样实现：

```python
import threading

# 实现synchronized装饰器，保证互斥访问
def synchronized(func):
    func.__lock__ = threading.Lock()    # 执行前加锁

    def synced_func(*args, **kws):
        with func.__lock__:     # with上下文管理，执行结束自动解锁
            return func(*args, **kws)

    return synced_func
    
...

# 使用例
@synchronized
def run():
    pass
```

于是，我们就可以使用Python真正地模拟管程。例如，可使用Python模拟管程实现生产者-消费者问题（带可视化）：[完整代码](https://github.com/DrSHW/OS-experiments/blob/main/%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E5%BC%95%E5%85%A5%E7%AE%A1%E7%A8%8B%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98.py)。

### 2.5.4 进程与管程的比较

管程和进程有以下不同点：

+ 管程定义的是**公用**的数据结构，而进程对应的是**私有**的数据结构；
+ 管程将共享变量上的**同步操作进行集中**；
+ 管程是为**管理共享资源**而建立的，进程主要是为**占有系统资源和实现系统并发性**而引入的；
+ 管程是被欲使用共享资源的进程所调用的，管程和调用它的进程**不能并行工作**，而进程之间**能并行工作**，并发性是其固有特性；
+ 管程是语言或操作系统的成分，**不必创建或撤销**，而进程**有生命周期**，由创建而产生至撤销便消亡。

#### 总结

<img src="https://images.drshw.tech/images/notes/image-20221101224543348.png" alt="image-20221101224543348" style="zoom: 50%;" />

引入管程的目的无非就是要更方便地实现进程互斥和同步：

1. 需要在管程中定义共享数据（如生产者消费者问题的缓冲区）；
2. 需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数（如生产者-消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品）；
3. 只有**通过这些特定的“入口”才能访问共享数据**；
4. 管程中有很多“入口”，但是**每次只能开放其中一个“入口”**，并且只能让一个进程或线程进入（如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。**注意：这种*<u>互斥特性</u>*是由编译器负责实现的，程序员不用关心**）；
5. 可在管程中设置**条件变量**及**等待/唤醒操作**以解决同步问题。可以让一个进程或线程在条件变量上等待（**此时，该进程应先释放管程的使用权，也就是让出“入口”**）；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。

程序员可以用某种特殊的语法定义一个管程（如定义一个类），之后其他程序员就可以使用这个管程提供的特定“入口”（比如由类实例化而来的对象）很方便地使用实现进程同步/互斥了。
