---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 2.5 管程

### 引言：为什么要实现管程？

![image-20221009231516493](https://images.drshw.tech/images/notes/image-20221009231516493.png)

为了实现程序对一些共享资源的互斥/同步访问，我们引入了管程。

### 2.5.1 管程的定义和基本特征

管程是一种特殊的软件模块，由以下部分组成：

1. 局部于管程的**共享数据结构**说明；
2. 对该数据结构进行操作的**一组过程**（函数）；
3. 对局部于管程的共享数据设置**初始值**的语句；
4. 管程有一个**名字**。

（类似于面向对象语言中的**类`class`**）

管程的基本特征：

1. 局部于管程的数据只能被局部于管程的过程所访问；
2. 一个进程只有通过调用管程内过程才能进入管程访问的共享数据；
3. **每次仅允许一个进程在管程内执行某个内部过程。**

### 2.5.2 管程的应用

#### 模拟管程

下面使用C++模拟管程逻辑，实现生产者-消费者问题。

管程中可设置条件变量和等待/唤醒操作，以解决同步问题。

代码如下：

```cpp
...

class Monitor
{
    /* 用于实现同步的条件变量 */
  	semaphre full = null;	// 表示缓冲区中已有的产品队列
    emptyQueue empty = null; // 表示缓冲区中空闲的位置队列
    /* 辅助变量 */
  	int count = 0, size;    // 缓冲区中的产品数和缓冲区大小
  	ProducerConsumer(int n)
  	{
    	size = n;
  	}
  	void insert(Item item)
  	{ // 将item放入缓冲区
    	if (count == size)
      		wait(full);
    	count++;
    	insert_item(item);
    	if (count == 1)
      		signal(empty);
  	}
  	Item remove()
  	{ // 从缓冲区取出一个产品
    	if (count == 0)
      		wait(empty);
    	count--;
    	if (count == N - 1)
      		signal(full);
    	return remove_item();
  	}
};

// 实例化管程
Monitor pc(10);

void producer()
{
  	while (true)
  	{
    	item = produce_item();		// 生产产品item
    	pc.insert(item);
  	}
}
// 消费者进程
void consumer()
{
  	while (true)
  	{
    	item = pc.remove();
    	consume_item(item); 		// 消费产品item
  	}
}

...
```

#### 使用Python装饰器实现`synchronized`（拓展）

坑，待填。

#### 总结

引入管程的目的无非就是要更方便地实现进程互斥和同步：

1. 需要在管程中定义共享数据（如生产者消费者问题的缓冲区）；
2. 需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数（如生产者-消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品）；
3. 只有**通过这些特定的“入口”才能访问共享数据**；
4. 管程中有很多“入口”，但是**每次只能开放其中一个“入口”**，并且只能让一个进程或线程进入（如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。**注意：这种*<u>互斥特性</u>*是由编译器负责实现的，程序员不用关心**）；
5. 可在管程中设置**条件变量**及**等待/唤醒操作**以解决同步问题。可以让一个进程或线程在条件变量上等待（**此时，该进程应先释放管程的使用权，也就是让出“入口”**）；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。

程序员可以用某种特殊的语法定义一个管程（如定义一个类），之后其他程序员就可以使用这个管程提供的特定“入口”（比如由类实例化而来的对象）很方便地使用实现进程同步/互斥了。
