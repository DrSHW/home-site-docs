---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 2.1 进程的描述与控制

### 2.1.1 进程的定义、组成、组织方式、特征

#### 定义

在仅支持单道程序的年代，**程序**（即指令序列）独占所有CPU、内存、I/O资源。此时程序的代码放在程序段内，程序执行过程处理的数据放在数据段内（如变量）。

<img src="https://images.drshw.tech/images/notes/image-20221005230220366.png" alt="image-20221005230220366" style="zoom:50%;" />

引入**多道**程序技术后，允许多个程序并发执行，此时各个程序的代码、运算数据存放的位置不同，并具有间断性和不可再现性的特征。

为了方便操作系统管理，完成各程序的并发执行，引入了**进程、进程实体**的概念，实现操作系统的并发行和共享性。

<img src="https://images.drshw.tech/images/notes/image-20221005231603210.png" alt="image-20221005231603210" style="zoom:50%;" />

为了使参与并发执行的程序能独立的运行，必须为之配置一个专门的数据结构，称之为进程控制块**PCB**（Process Control Block），系统利用PCB来描述进程的基本情况和运行状态（如程序代码存放位置），进而控制和管理进程。

**PCB、程序段、数据段**三部分构成了**进程实体**（**进程映像**）。一般情况下，我们把进程实体就简称为进程，例如，所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体的PCB。值得注意的是，进程实体是**静态的**，而进程是**动态的**过程。

从不同的角度，进程可以有不同的定义，比较经典的定义有：

+ 进程是程序的一次**执行过程**；

+ 进程是一个程序及其数据在处理器上顺序执行时所**发生的活动**；

+ 进程是具有独立功能的程序在一个数据集合上**运行的过程**，他是系统进行资源分配和调度的一个独立单位。

可以看出来，这三个定义都特别地强调了一点，即进程是**动态**的过程。

在引入了进程实体的概念后，可把进程定义为：

+ **进程**是进程实体的**运行过程**，是系统进行**资源分配**和**调度**的一个独立单位。

#### 组成

我们已经知道，**进程**（**进程实体**）由**PCB、程序段、数据段**组成，下面我们聊聊PCB的组成。

PCB主要由以下四个部分组成：

+ 进程标识符（PID）：

  当进程被创建时，操作系统会为该进程分配唯一的、不重复的ID，用于区分不同的进程（类似于身份证号）；

+ 处理机状态：

  当进程切换时需要把进程当前的运行情况记录下来保存在PCB中，如程序计数器的值表示了当前程序执行到哪一句；

+ 进程调度信息：

  包括进程当前状态、优先级、等待和使用CPU的时间总和等信息，用作进程调度和对换的依据；

+ 进程控制信息：

  包括程序和数据的地址、进程同步和通信信息、资源清单和进程队列指针等。

<img src="https://images.drshw.tech/images/notes/image-20221005233101274.png" alt="image-20221005233101274" style="zoom:37%;" />

#### 组织方式

在一个系统，通常有数十，数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。

注：进程的**组成**讨论的是**一个进程内部**由哪些部分构成的问题，而进程的**组织**讨论的是**多个进程间**的组织方式问题。

进程的组织方式可分为索引方式和链接方式：

<img src="https://images.drshw.tech/images/notes/image-20221005233823145.png" alt="image-20221005233823145" style="zoom:50%;" />

+ 链接方式：

  操作系统会持有一系列的指针，每个指针会指向不同状态的进程队列：

  <img src="https://images.drshw.tech/images/notes/image-20221005234141307.png" alt="image-20221005234141307" style="zoom:50%;" />

+ 索引方式：

  与链接方式类似，只不过指针指向的不是一个队列，而是一个索引表，索引表中的表项也是指针，指向不同的进程：

  <img src="https://images.drshw.tech/images/notes/image-20221005234345333.png" alt="image-20221005234345333" style="zoom:50%;" />

#### 特征

进程和程序是两个截然不同的概念，相比于程序，进程拥有以下特征：

<img src="https://images.drshw.tech/images/notes/image-20221005234708469.png" alt="image-20221005234708469" style="zoom:50%;" />

### 2.1.2 进程的状态与转换

#### 进程的状态

进程是程序的一次执行。在程序的执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务。可见，进程的状态是会有各种变化 的。为了方便对于各个进程的管理，操作系统需要将进程合理地划分为几种状态。

进程有三种基本状态：

1. **运行态**（Running）：

   指进程占有CPU，且在CPU上运行的状态。值得注意的是，在单处理器的环境下，每一时刻最多只有一个进程处于运行状态；

2. **就绪态**（Ready）：

   指已经具备运行条件，但由于没有空闲CPU，而暂时不能运行。此时进程已经获得了除CPU之外的一切所需资源，一旦得到处理器即可运行；

3. **阻塞态**（Blocked/Waiting 等待态）：

   进程正在等待某一事件而暂停运行。如：等待操作系统分配打印机、等待磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务。

另外两种状态：

4. **创建态**（New 新建态）：

   指进程正在被创建，尚未转到就绪状态。在此状态，进程正在被创建，操作系统为进程分配资源，初始化PCB。

5. **终止态**（Terminated 结束态）：

   当进程需要结束运行时，系统首先必须置该进程为结束状态。在此状态，操作系统需要完成撤销进程相关的工作。完成将分配给进程的资源回收，撤销进程PCB等工作。

<img src="https://images.drshw.tech/images/notes/image-20221006002042513.png" alt="image-20221006002042513" style="zoom: 50%;" />

#### 进程状态的转换

整体的转换过程如下图：

<img src="https://images.drshw.tech/images/notes/image-20221006111051901.png" alt="image-20221006111051901" style="zoom:50%;" />

注意：**不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态**（因为阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求）。

### 2.1.3 进程控制

#### 基本概念

进程控制的主要功能是对系统中所有进程实施有效地管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。

进程控制的目的就是要实现**进程状态转换**。

进程控制的总体流程如下：

<img src="https://images.drshw.tech/images/notes/image-20221006111645851.png" alt="image-20221006111645851" style="zoom:50%;" />

上述的这些状态转换操作都应当一次执行完毕，若操作过程中产生了中断，后果十分严重（比如在创建态->就绪态时，只修改了PCB，而未修改相应队列，将会导致冲突）。

于是，引入了**原语**的概念，用它来实现进程控制。原语的特点是执行期间**不允许中断**，只能一气呵成。这种操作也被称为**原子操作**。

原语采用“**关中断**指令”和“**开中断**指令”实现：在执行原语代码前，会先执行**关中断**指令，此时会暂时屏蔽外部中断信号；执行完原语代码后，执行**开中断**指令，此时就能接收外部中断信号了。（关/开 中断指令都是只允许在**核心态**下执行的特权指令）

#### 进程控制相关的原语

<img src="https://images.drshw.tech/images/notes/image-20221006113004450.png" alt="image-20221006113004450" style="zoom:50%;" />

进程创建原语的功能和引起进程创建的事件：

<img src="https://images.drshw.tech/images/notes/image-20221006113201881.png" alt="image-20221006113201881" style="zoom:50%;" />

进程撤销原语的功能和引起进程终止的事件：

<img src="https://images.drshw.tech/images/notes/image-20221006113446203.png" alt="image-20221006113446203" style="zoom:50%;" />

进程的阻塞和唤醒：

<img src="https://images.drshw.tech/images/notes/image-20221006113555982.png" alt="image-20221006113555982" style="zoom:50%;" />

进程切换是指当前正在运行的进程被转换到其他状态后，再回到继续运行的过程。这个过程中，进程的运行环境产生了实质性的变化。

进程的切换原语的功能和引起进程切换的事件：

<img src="https://images.drshw.tech/images/notes/image-20221006113654052.png" alt="image-20221006113654052" style="zoom:50%;" />

### 2.1.4 进程通信

进程通信就是进程之间的数据交换。

进程是分配系统资源的单位（包括内存地址空间），因此**各进程**拥有的**内存地址空间相互独立**。

为了保证安全，**一个进程不能直接访问另一个进程的地址空间**。但是，进程之间的信息交换又是必须实现的（就比如使用QQ发图片时需要访问相册）。为了保证进程间的安全通信，操作系统提供了一些方法：**共享存储**、**消息传递**和**管道通信**。

#### 共享存储

即通信的进程之间存在着一块可以直接访问的**共享空间**，通过对这块共享空间的读写操作实现进程之间的信息交换：

<img src="https://images.drshw.tech/images/notes/image-20221006123524604.png" alt="image-20221006123524604" style="zoom:50%;" />

需要注意的是，两个进程对共享空间的**访问**必须是**互斥**的（一个进程在其中写数据时，其它进程不可访问）。互斥操作可以由操作系统提供的同步互斥工具实现（如后续会讲到的`P`、`V`操作）。

共享存储也可以分为基于数据结构的共享和基于存储区的共享：

+ **基于数据结构**的共享：

  例如：共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种**低级通信**方式。

+ **基于存储区**的共享：

  即在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种**高级通信**方式。

#### 管道通信

“管道”是指用于连接读写进程的一个共享文件，有名`pipe`文件。其实就是在内存中开辟一个大小固定的缓冲区：

<img src="https://images.drshw.tech/images/notes/image-20221006124738832.png" alt="image-20221006124738832" style="zoom:50%;" />

需要注意的是：

1. 管道只能采取**半双工通信**，某一时间段只能实现单向的传输。如果要实现**双向同时通信**，则**需要设置两个管道**（上图即为两个管道）；
2. 各进程需要**互斥**地访问管道；
3. 数据以字符流的形式写入管道，当**管道写满**时，**写进程**的`write()`系统将被**阻塞**，等待读进程将数据取走。当读进程将数据全部取走后，**管道变空**，此时**读进程**的`read()`系统调用将被**阻塞**。
4. 如果**没有写满，就不允许读**。如果**没有读空，就不允许写**。
5. 数据一旦被读出，就从管道中被抛弃，这就意味着**读进程最多只能有一个**，否则可能会有读错数据的情况。

#### 消息传递

进程间的数据交换以**格式化的消息**（Message）为单位。进程通过操作系统提供的“发送消息 / 接收消息”两个**原语**进行数据交换。

消息的结构：

<img src="https://images.drshw.tech/images/notes/image-20221006125410161.png" alt="image-20221006125410161" style="zoom:50%;" />

消息传递分为直接通信方式和间接通信方式：

+ **直接通信**方式：

  消息直接挂到接收进程的消息缓冲队列上；

+ **间接通信**方式：

  消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。（例如计网中的电子邮件系统）

### 2.1.5 线程概念和多线程模型

#### 线程的概念和作用

引入进程的目的，是为了是多道程序能并发执行，以提高资源利用率和系统吞吐量；而引入**线程**，则是为了减小程序在并发执行时所付出的时空开销，**提高操作系统的并发性能**。

引入线程后，CPU的服务对象就不再是进程，而是进程中的**线程**。每个进程中可能会包含多个线程，CPU会采用特定的算法轮流地为这些线程提供服务。

<img src="https://images.drshw.tech/images/notes/image-20221006130144277.png" alt="image-20221006130144277" style="zoom:50%;" />

可以把线程理解为“轻量级进程”。

**线程**是一个**基本的CPU执行单元**，也是**程序执行流的最小单位**。引入线程之后，不仅是进程之间可以并发，进程内的**各线程之间**也可以**并发**，从而进一步**提升了系统的并发度**，使得一个进程内也可以并发处理各种任务( 如QQ视频、文字聊天、传文件）。

引入线程后，**进程**只作为**除CPU之外的系统资源的分配单元**（如打印机、内存地址空间等都是分配给进程的）。

引入线程后带来的变化：

<img src="https://images.drshw.tech/images/notes/image-20221006130917814.png" alt="image-20221006130917814" style="zoom:50%;" />

<img src="https://images.drshw.tech/images/notes/image-20221006131026409.png" alt="image-20221006131026409" style="zoom:50%;" />

#### 线程的属性

<img src="https://images.drshw.tech/images/notes/image-20221006131059475.png" alt="image-20221006131059475" style="zoom:50%;" />

#### 线程的实现方式

线程的实现可以分为两类：用户级线程和内核级线程。

+ **用户级线程**：

  用户级线程由应用程序通过线程库实现。

  所有的**线程管理工作**都由**应用程序负责**（包括线程切换）。

  用户级线程中，**线程切换**可以在**用户态下即可完成**，无需操作系统干预。

  在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。(用户级线程对用户不透明，对操作系统透明)

  可以这样理解，“**用户级线程**”就是“**从用户视角看能看到的线程**”。

  <img src="https://images.drshw.tech/images/notes/image-20221006131313874.png" alt="image-20221006131313874" style="zoom:50%;" />

+ **内核级线程**：

  <img src="https://images.drshw.tech/images/notes/image-20221006131658902.png" alt="image-20221006131658902" style="zoom:50%;" />

  内核级**线程的管理工作**由**操作系统内核**完成。线程调度、切换等工作都由内核负责，因此**内核级线程的切换**必然需要在**核心态**下才能完成。

  可以这样理解，“**内核级线程**”就是“**从操作系统内核视角看能看到的线程**”。

在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将`n`个用户级线程映射到`m`放内核级线程上（`n >= m`）。

<img src="https://images.drshw.tech/images/notes/image-20221006132122277.png" alt="image-20221006132122277" style="zoom:50%;" />

操作系统只“看得见”内核级线程，因此只有**内核级线程才是处理机分配的单位**。

例如：上图模型中，该进程由两个内核级线程，三个用户级线程，在用户看来，这个进程中有三个线程。但即使该进程在一个4核处理机的计算机上运行，也最多只能被分配到两个核，最多只能有两个用户线程并行执行。

#### 多线程模型

在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题，引出了“多线程模型”的问题。

多线程模型分为

+ **多对一**模型：

  多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。

  优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高；

  缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。

  <img src="https://images.drshw.tech/images/notes/image-20221006132426506.png" alt="image-20221006132426506" style="zoom:50%;" />

+ **一对一**模型：

  一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。

  优点：当一个线程被阻塞后，可以继续执行，并发能力强。多线程可在多核处理机上并行执行；

  缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

  <img src="https://images.drshw.tech/images/notes/image-20221006132538666.png" alt="image-20221006132538666" style="zoom:50%;" />

+ **多对多**模型：

  多对多模型：`n`个用户级线程映射到`m`个内核级线程（`n >= m`）。，每个用户进程对应`m`个内核级线程。

  克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。

  <img src="https://images.drshw.tech/images/notes/image-20221006132831615.png" alt="image-20221006132831615" style="zoom:50%;" />