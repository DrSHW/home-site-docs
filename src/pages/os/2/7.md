---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---
## 2.7  线程的基本概念与实现

<img src="https://images.drshw.tech/images/notes/image-20221101231022803.png" alt="image-20221101231022803" style="zoom:50%;" />

### 2.7.1 线程的概念和作用

引入进程的目的，是为了是多道程序能并发执行，以提高资源利用率和系统吞吐量；而引入**线程**，则是为了减小程序在并发执行时所付出的时空开销，**提高操作系统的并发性能**。

引入线程后，CPU的服务对象就不再是进程，而是进程中的**线程**。每个进程中可能会包含多个线程，CPU会采用特定的算法轮流地为这些线程提供服务。

<img src="https://images.drshw.tech/images/notes/image-20221006130144277.png" alt="image-20221006130144277" style="zoom:50%;" />

可以把线程理解为“**轻量级进程**”。

**线程**是一个**基本的CPU执行单元**，也是**程序执行流的最小单位**。引入线程之后，不仅是进程之间可以并发，进程内的**各线程之间**也可以**并发**，从而进一步**提升了系统的并发度**，使得一个进程内也可以并发处理各种任务( 如QQ视频、文字聊天、传文件）。

引入线程后，**进程**只作为**除CPU之外的系统资源的分配单元**（如打印机、内存地址空间等都是分配给进程的）。

引入线程后带来的变化：

<img src="https://images.drshw.tech/images/notes/image-20221006130917814.png" alt="image-20221006130917814" style="zoom:50%;" />

<img src="https://images.drshw.tech/images/notes/image-20221006131026409.png" alt="image-20221006131026409" style="zoom:50%;" />

> **线程会不会被挂起？**
>
> 挂起是因为资源不足，线程没有资源，所以没有挂起一说。（进程被挂起时，它所属的线程确实全都一并挂起了，但不能说是线程挂起了）

### 2.7.2 线程的属性

<img src="https://images.drshw.tech/images/notes/image-20221006131059475.png" alt="image-20221006131059475" style="zoom:50%;" />

### 2.7.3 线程的实现方式

线程的实现可以分为两类：用户级线程和内核级线程。

+ **用户级线程**：

  用户级线程由应用程序通过线程库实现。

  所有的**线程管理工作**都由**应用程序负责**（包括线程切换）。

  用户级线程中，**线程切换**可以在**用户态下即可完成**，无需操作系统干预。

  在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。(用户级线程对用户不透明，对操作系统透明)

  可以这样理解，“**用户级线程**”就是“**从用户视角看能看到的线程**”。

  <img src="https://images.drshw.tech/images/notes/image-20221006131313874.png" alt="image-20221006131313874" style="zoom:50%;" />

+ **内核级线程**：

  <img src="https://images.drshw.tech/images/notes/image-20221006131658902.png" alt="image-20221006131658902" style="zoom:50%;" />

  内核级**线程的管理工作**由**操作系统内核**完成。线程调度、切换等工作都由内核负责，因此**内核级线程的切换**必然需要在**核心态**下才能完成。

  可以这样理解，“**内核级线程**”就是“**从操作系统内核视角看能看到的线程**”。

在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将`n`个用户级线程映射到`m`放内核级线程上（`n >= m`）。

<img src="https://images.drshw.tech/images/notes/image-20221006132122277.png" alt="image-20221006132122277" style="zoom:50%;" />

操作系统只“看得见”内核级线程，因此只有**内核级线程才是处理机分配的单位**。

例如：上图模型中，该进程由两个内核级线程，三个用户级线程，在用户看来，这个进程中有三个线程。但即使该进程在一个4核处理机的计算机上运行，也最多只能被分配到两个核，最多只能有两个用户线程并行执行。

### 2.7.4 多线程模型

在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题，引出了“多线程模型”的问题。

多线程模型分为

+ **多对一**模型：

  多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。

  优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高；

  缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。

  <img src="https://images.drshw.tech/images/notes/image-20221006132426506.png" alt="image-20221006132426506" style="zoom:50%;" />

+ **一对一**模型：

  一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。

  优点：当一个线程被阻塞后，可以继续执行，并发能力强。多线程可在多核处理机上并行执行；

  缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

  <img src="https://images.drshw.tech/images/notes/image-20221006132538666.png" alt="image-20221006132538666" style="zoom:50%;" />

+ **多对多**模型：

  多对多模型：`n`个用户级线程映射到`m`个内核级线程（`n >= m`）。，每个用户进程对应`m`个内核级线程。

  克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。

  <img src="https://images.drshw.tech/images/notes/image-20221006132831615.png" alt="image-20221006132831615" style="zoom:50%;" />
