---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 5.3 置换算法

由于页面的换入、换出需要磁盘I/O，会有较大的开销，因此好的页面置换算法应该**追求更少的缺页率**。

常见的置换算法有以下几种：

<img src="https://images.drshw.tech/images/notes/image-20221026171927477.png" alt="image-20221026171927477" style="zoom: 30%;" />

### 5.3.1 最佳置换算法 OPT

最佳置换算法（OPT，Optimal）：每次选择**淘汰的页面**将是**以后永不使用**，或者**在最长时间内不再被访问的页面**，这样可以保证最低的缺页率。

例：假设系统为某进程分配了三个内存块，并考虑到有页面引用串（会依次访问这些页面）：`7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1`，若使用**最佳置换算法**，这一过程中内存的状态如下表：

<img src="https://images.drshw.tech/images/notes/image-20221026210053540.png" alt="image-20221026210053540" style="zoom:30%;" />

说明：

+ 首次访问页面2时，内存占满，需要将一个内存块中的页面换出内存，此时内存块中存在页面`7, 0, 1`；
+ 再看以后需要访问的页面，其中页面`7`出现的要比页面`0`和页面`1`都要**晚**（在倒数第三个位置才会出现），故将页面`7`换出内存；
+ 后续同理。

整个过程

+ **缺页中断**发生了**9次**，**页面置换**发生了**6次**；
+ **缺页率**：`9/20 = 45%`。

注意：缺页时未必发生页面置换。若还有可用的空闲内存块，就不用进行页面置换。

最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，**最佳置换算法是无法实现的**。

### 5.3.2 先进先出置换算法 FIFO

先进先出置换算法（FIFO，First In First Out）：每次选择**淘汰的页面**是**最早进入内存的页面**。

实现方法：将调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时换出队尾页面，将新页面插入队头即可。队列的最大长度取决于系统为进程分配了多少个内存块。

例：假设系统为某进程分配了**三个**内存块，并考虑到有页面号引用串：`3, 2, 1, 0, 3, 2, 4, 3, 2, 1, 0, 4`，这一过程中内存的状态如下表：

<img src="https://images.drshw.tech/images/notes/image-20221026212347169.png" alt="image-20221026212347169" style="zoom:30%;" />

说明：

+ 在首次访问页面`0`时，需要将某内存块换出内存；
+ 此时队列为`3 -> 2 -> 1`，故换出页面`3`，换入页面`0`，此时队列变为`1 -> 0 -> 3`；
+ 后续同理。

若系统为该进程分配了**四个**内存块，情况会变为：

<img src="https://images.drshw.tech/images/notes/image-20221026213100850.png" alt="image-20221026213100850" style="zoom:30%;" />

我们发现：分配**三个**内存块时，缺页次数为**9次**；而分配**四个**内存块时，缺页次数反而上升至**10次**；

此现象称为：**Belady 异常**——当为进程分配的物理块数增大时，缺页次数**不减反增**的异常现象。

**只有FIFO算法会产生Belady异常。**另外，FIFO算法虽然**实现简单**，但是该算法与进程实际运行时的规律并不适应，因为先进入的页面也有可能最常被访问，故其**算法性能较差**。

### 5.3.3 最近最久未使用置换算法 LRU

最近最久未使用置换算法（LRU，Least Recently Used）：每次**淘汰的页面**时**最近最久未使用的页面**。

实现方法：

+ 赋予每个页面的对应表项中，用**访问字段记录该页面自上次被访问以来所经历的时间`t`** ：

  <img src="https://images.drshw.tech/images/notes/image-20221026214455190.png" alt="image-20221026214455190" style="zoom:30%;" />

+ 当需要淘汰一个页面时，选择现有页面中`t`值最大的，即最近最久未使用的页面。

例：假设系统为某进程分配了**四个**内存块，并考虑有页面号引用串：`1, 8, 1, 7, 8, 2, 7, 2, 1, 8, 3, 8, 2, 1, 3, 1, 7, 1, 3, 7`，这一过程中内存的状态如下表：

<img src="https://images.drshw.tech/images/notes/image-20221026214838247.png" style="zoom:30%;" />

说明：

+ 在首次访问页面`3`时，需要将某内存块换出内存；
+ 检索所有内存块中的页面，发现页面`7`是最近最长时间未被使用的，故将其换出；
+ 后续同理。

在手动做题是，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在**逆向扫描过程中最后一个出现的页号就是要淘汰的页面**。

该算法的实现需要专门的硬件支持，虽然算法**性能好**，但是**实现困难，开销大**。

### 5.3.4 时钟置换算法 CLOCK/NRU

> 最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久置换算法性能好，是最接近OPT算法性能的，但是实现起来又需要专门的硬件支持，算法开销大。

**时钟置换算法**是一种性能和开销较均衡的算法，又称**CLOCK算法**，或**最近未用算法**（**NRU**，Not Recently Used）

#### 简单的 CLOCK 算法

**简单的CLOCK算法**实现方法：

1. 为每个页面设置一个**访问位**，再将内存中的页面都通过链接指针**链接成一个循环队列**；

   <img src="https://images.drshw.tech/images/notes/image-20221026221132074.png" alt="image-20221026221132074" style="zoom:30%;" />

2. 当某页被访问时，其访问位置为1；

3. 当需要淘汰一个页面时，只需检查页的访问位——如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面；

4. 若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此**简单的CLOCK算法**选择一个淘汰页面**最多会经过两轮扫描**）。

例：假设系统为某进程分配了五个内存块，并考虑到有页面号引用串：`1, 3, 4, 2, 5, 6, 3, 4, 7`，这一过程中内存的状态：

依次访问`1, 3, 4, 2, 5`时，访问位均为1，内存占满：<img src="https://images.drshw.tech/images/notes/image-20221026221430609.png" alt="image-20221026221430609" style="zoom:30%;" />

首次访问6号页时，进行扫描，由于第一次扫描后，访问位均为1，故依次将访问位置为0：<img src="https://images.drshw.tech/images/notes/image-20221026222240820.png" alt="image-20221026222240820" style="zoom:30%;" />

此时指针指向1号页，其访问位为0，故将其替换为6号页：<img src="https://images.drshw.tech/images/notes/image-20221026223425839.png" alt="image-20221026223425839" style="zoom:30%;" />

下面依次访问3号页和4号页：

<img src="https://images.drshw.tech/images/notes/image-20221026223509616.png" alt="image-20221026223509616" style="zoom:30%;" /><img src="https://images.drshw.tech/images/notes/image-20221026223545015.png" alt="image-20221026223545015" style="zoom:30%;" />

下面需要访问7号页，进行扫描，3号页和4号页中的访问位变为0；最先找到2号页的访问位为0，故淘汰2号页；并将7号页加入，访问为置为1：

<img src="https://images.drshw.tech/images/notes/image-20221026224303760.png" alt="image-20221026224303760" style="zoom:30%;" /><img src="https://images.drshw.tech/images/notes/image-20221026224410888.png" alt="image-20221026224410888" style="zoom:30%;" />

后续同理。

#### 改进型的 CLOCK 算法

**简单的时钟置换算法**仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。**只有被淘汰的页面被修改过时，才需要写回外存**。

因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应该考虑页面有没有被修改过。**在其他条件都相同时，应优先淘汰没有修改过的页面**，避免I/O操作。这就是改进型的时钟置换算法的思想。

为了实现这一点，会在简单算法的前提下新增一个**修改位**，代表页面是否被修改过：

+ **修改位为0**，代表页面没有被修改过；
+ **修改位为1**，代表页面修改过。

为方便讨论，使用**`(访问位, 修改位)`**的形式表示各页面状态。如`(1, 1)`表示一个页面近期被访问过，且被修改过。

**算法规则：**

先将所有可能被置换的页面排成一个循环队列，然后进行扫描：

+ 第一轮扫描：从当前位置开始扫描到第一个`(0, 0)`的帧用于替换。本轮扫描不修改任何标志位；

  （第一优先级：最近没访问，且没修改的页面）

+ 第二轮扫描：若第一轮扫描失败，则重新扫描，查找第一个`(0, 1)`的帧用于替换。本轮将所有扫描过的帧访问位设为0；

  （第二优先级：最近没访问，但修改过的页面）

+ 第三轮扫描：若第二轮扫描失败，则重新扫描，查找第一个`(0, 0)`的帧用于替换。本轮扫描不修改任何标志位；

  （第三优先级：最近访问过，但没修改的页面）

+ 第四轮扫描：若第三轮扫描失败，则重新扫描，查找第一个`(0, 1)`的帧用于替换。

  （第四优先级：最近访问过，且修改过的页面）

由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描，一定会有一个帧被选中，因此**改进型CLOCK算法**选择一个淘汰页面**最多会进行四轮扫描**。

例：假设系统为某进程分配了五个内存块，使用改进型的CLOCK算法，内存占满后排列成循环队列：

+ 情况一，状态如下：

  <img src="https://images.drshw.tech/images/notes/image-20221026231741205.png" alt="image-20221026231741205" style="zoom:30%;" />

  此时欲淘汰一个页面，需要进行第一次扫描，成功找到页帧`(0, 0)`并将其替换：

  <img src="https://images.drshw.tech/images/notes/image-20221026230435398.png" alt="image-20221026230435398" style="zoom:30%;" />

+ 情况二，状态如下：

  <img src="https://images.drshw.tech/images/notes/image-20221026230823483.png" alt="image-20221026230823483" style="zoom:30%;" />

  未找到页帧`(0, 0)`，第一次扫描失败，此时指针指向最后一个页面：

  <img src="https://images.drshw.tech/images/notes/image-20221026234000541.png" alt="image-20221026234000541" style="zoom: 30%;" />

  进行第二轮扫描，查找页帧`(0, 1)`，将其替换；扫描经过的帧访问位均会被置为0：

  <img src="https://images.drshw.tech/images/notes/image-20221026234228086.png" alt="image-20221026234228086" style="zoom:30%;" />

+ 情况三，状态如下：

  <img src="https://images.drshw.tech/images/notes/image-20221026234300183.png" alt="image-20221026234300183" style="zoom:30%;" />

  第一轮扫描失败，第二轮扫描未找到页帧`(0, 1)`，也失败，扫描后状态如下：

  <img src="https://images.drshw.tech/images/notes/image-20221026234614648.png" alt="image-20221026234614648" style="zoom:30%;" />

  第三轮扫描，成功找到了页帧`(0, 0)`，将其替换：

  <img src="https://images.drshw.tech/images/notes/image-20221026234751764.png" alt="image-20221026234751764" style="zoom:30%;" />

+ 情况四，状态如下：

  <img src="https://images.drshw.tech/images/notes/image-20221026235054741.png" alt="image-20221026235054741" style="zoom:30%;" />

  第一轮扫描失败，第二轮扫描也失败，扫描后状态如下：

  <img src="https://images.drshw.tech/images/notes/image-20221026235152170.png" alt="image-20221026235152170" style="zoom:30%;" />

  第三轮未找到页帧`(0, 0)`，扫描失败；第四轮扫描中，第一个页帧就是`(0, 1)`，将其替换：

  <img src="https://images.drshw.tech/images/notes/image-20221026235347669.png" alt="image-20221026235347669" style="zoom:30%;" />

  

  

