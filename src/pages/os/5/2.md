---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 5.2 请求分页存储管理方式

### 5.2.1 请求分页存储管理的特性

**请求分页**存储管理与**基本分页**存储管理的主要区别：

在程序执行过程中，当所**访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存**，然后继续执行程序。

若内存空间不够，由操作系统负责**将内存中暂时用不到的信息换出到外存**。

新增了三个步骤：

+ 提供**请求调页**功能，将缺失页面从外存调入内存；
+ 提供**页面置换**功能，将暂时用不到的页面换出外存；
+ 需要**修改**请求页表中新增的表项。

<img src="https://images.drshw.tech/images/notes/image-20221025183132865.png" alt="image-20221025183132865" style="zoom:50%;" />

### 5.2.2 页表机制

与基本分页管理相比，请求分页管理中，为了实现“**请求调页**”，操作系统需要知道每个页面是否已经调入内存；如果还没调入，那么也需知道该页面在外存中存放的位置。

当内存空间不够时，要实现“**页面置换**”，操作系统需要通过某些指标来决定到底要换出哪个页面；有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改过信息。

请求分页存储管理的页表：

<img src="https://images.drshw.tech/images/notes/image-20221025171259281.png" alt="image-20221025171259281" style="zoom:50%;" />→<img src="https://images.drshw.tech/images/notes/image-20221025171426316.png" alt="image-20221025171426316" style="zoom:50%;" />

请求页表项增加了四个字段：

+ 状态位：即是否已调入内存；
+ 访问字段：可记录最近被访问过的次数，或上次访问的时间，供置换算法选择换出页面时参考；
+ 修改位：即页面调入内存后是否被修改过；
+ 外存地址：页面在外存中的存放位置。

### 5.2.3 缺页中断机构

#### 缺页中断的产生和处理流程

在请求分页系统中，每当要访问的**页面不在内存**时，便产生一个**缺页中断**，然后由操作系统的缺页**中断处理程序处理中断**。

此时**缺页的进程阻塞**，放入阻塞队列，调页**完成后再将其唤醒**，放回就绪队列。

如果内存中**有空闲块**，则为进程**分配一个空闲块**，将所缺页面装入该块，并修改页表中相应的页表项。

如果内存中**没有空闲块**，则**由页面置换算法选择一个页面淘汰**，若该页面在内存期间**被修改过**，则要将其**写回外存**。未修改过的页面不用写回外存。

#### 其它要点

**缺页中断**是因为当前执行的指令想要访问的目标未调入内存而产生的，因此属于内中断。

**一条指令**执行期间，**可能产生多次缺页中断**。（如：`copy A to B`，即将逻辑地址`A`中的数据复制到逻辑地址`B`，而`A`、`B`属于不同的页面，则有可能产生两次中断）

### 5.2.4 地址变换机构

请求分页存储管理中，从逻辑地址A到物理地址E的变换过程如下：

<img src="https://images.drshw.tech/images/notes/image-20221025173743415.png" alt="image-20221025173743415" style="zoom:50%;" />

上图快表中有的页面一定是**在内存中的**。若某个页面被换出外存，则快表中的相应表项也要删除，否则可能访问错误的页面。

其中我们需要重点关注请求分页存储管理[新增的三个步骤](https://docs.drshw.tech/os/5/2/#521-%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E7%89%B9%E6%80%A7)即可，书上的过程写的非常详细（左半边框出的即为新增步骤）：

<img src="https://images.drshw.tech/images/notes/image-20221025175131285.png" alt="image-20221025175131285" style="zoom:40%;" />

补充细节：

① 只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数；

② 和普通的中断处理一样，缺页中断依然需要保留CPU现场；

③ 需要用某种[页面置换算法](https://docs.drshw.tech/os/5/3/)来决定下一个换出页面；

④ 换入/换出页面都需要启动慢速的`I/O`操作。可见，如果换入/换出太频繁，会有很大的开销；

⑤ 页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。

在具有快表机构的请求分页系统中，访问一个逻辑地址时，若发生缺页，则**地址变换步骤**是：

```
查快表(未命中) -> 查慢表(发现未调入内存) -> 调页(调入的页面对应的表项会直接加入快表) -> 查快表(命中) -> 访问目标内存单元
```

