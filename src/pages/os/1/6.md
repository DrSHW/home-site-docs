---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 1.6 系统调用

### 1.6.1 什么是系统调用

在[1.1](https://docs.drshw.tech/os/introduction/)小节中，我们已经提到过**系统调用**这个概念。系统调用是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。

<img src="https://images.drshw.tech/images/notes/image-20221005161950881.png" alt="image-20221005161950881" style="zoom:55%;" />

应用程序通过**系统调用**请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，有操作系统代为完成。这样可以**保证系统的安全性和稳定性**，防止用户进行非法操作。

系统调用有以下几种分类：

<img src="https://images.drshw.tech/images/notes/image-20221005162400776.png" alt="image-20221005162400776" style="zoom:50%;" />

系统调用相关处理涉及对系统资源的管理、对进程的控制，这些功能需要执行一些**特权指令**才能完成。因此，**系统调用的相关处理**需要在**核心态**下进行。

### 1.6.2 系统调用背后的过程

举个例子，如果我们在高级语言中调用`write()`函数，假定该函数为一个系统调用。执行程序时，它将被编译为：

```asm
...
movl $4, %eax	# 将参数放入寄存器
...
int $0x80	# 执行陷入指令，int代表interrupt
...
```

由于高级语言是在用户程序中执行，这段汇编代码运行在**用户态**。

执行到陷入指令`int $0x80`时，操作系统将获得CPU的控制权，就会处理系统调用的相关代码，此时代码就运行在核心态了。

<img src="https://images.drshw.tech/images/notes/image-20221005164249563.png" alt="image-20221005164249563" style="zoom:55%;" />

总结系统调用处理流程：

> 传入系统调用参数 -> 执行陷入指令（**用户态**）-> 执行系统调用响应服务程序（**核心态**）-> 返回用户程序

注意：

1. **陷入指令**是在**用户态**执行的，执行陷入指令后立即引发一个**内中断**，从而CPU**进入核心态**；
2. **发出系统调用请求**是在**用户态**，而**对系统调用的相应处理**在**核心态**下进行；
3. 陷入指令时唯一一个只能在用户态下执行，而不可在核心态执行的指令。