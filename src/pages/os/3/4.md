---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 3.4 处理死锁的基本方法

### 3.4.1 死锁的几种处理策略

可以使用以下的几种思路处理死锁：

1. 预防死锁。破坏死锁产生的[四个必要条件](https://docs.drshw.tech/os/3/3/#332-%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6)中的一个或几个；
2. 避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）；
3. 死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。

<img src="https://images.drshw.tech/images/notes/image-20221015221259630.png" alt="image-20221015221259630" style="zoom:50%;" />

下面详细展开说明。

### 3.4.2 预防死锁

即需要破坏死锁产生的必要条件：

<img src="https://images.drshw.tech/images/notes/image-20221016001119097.png" alt="image-20221016001119097" style="zoom:50%;" />

#### 破坏互斥条件

如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：**`SPOOLing`技术**。

操作系统陆采用`SPOOLing`技术将独占设备在逻辑上改造成共享设备。比如，用`SPOOLing`技术将打印机改造为共享设备：

<img src="https://images.drshw.tech/images/notes/image-20221015225316923.png" alt="image-20221015225316923" style="zoom:50%;" />

该策略的**缺点**：

+ 并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，**很多时候都无法破坏互斥条件**。

#### 破坏不剥夺条件

有以下几种方案：

+ 方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件；
+ 方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）；

该策略的**缺点**：

1. 实现起来比较**复杂**；
2. 释放已获得的资源可能造成前一阶段工作的**失效**。因此这种方法 一般只适用于易保存和恢复状态的资源，如CPU；
3. 反复地申请和释放资源会增加系统开销，**降低系统吞吐量**；
4. 若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就需要放弃，以后再重新申请，如果一直发生这样的情况，就会导致**进程饥饿**。

#### 破坏请求和保持条件

可以**采用静态分配方法**，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。

该策略实现起来简单，但也有明显的**缺点**：

+ 有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，使得**资源利用率极低**。另外，该策略也有**可能导致某些进程饥饿**：

  <img src="https://images.drshw.tech/images/notes/image-20221015233447881.png" alt="image-20221015233447881" style="zoom:60%;" />

  如上图，若A类进程一直占用资源1，B类进程一直占用资源2，就会导致想要访问资源1和资源2的进程C饥饿。

#### 破坏循环等待条件

可采用**顺序资源分配法**。首先给系统中的资源编号，规定每个进程**必须按编号递增的顺序请求资源**，同类资源（即编号相同的资源）一次申请完。

原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。

<img src="https://images.drshw.tech/images/notes/image-20221016000730644.png" alt="image-20221016000730644" style="zoom:50%;" />

该策略的**缺点**：

1. **不方便增加新的设备**，因为可能需要重新分配所有的编号；
2. 进程实际使用资源的顺序可能和编号递增顺序不一致，会导致**资源浪费**；
3. 必须按规定次序申请资源，用户**编程麻烦**。

### 3.4.3 避免死锁

#### 安全序列

所谓**安全序列**，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成（不会存在因超出系统资源上限，而无法满足任一进程的需求的情况）。只要能找出一个安全序列，系统就是**安全状态**。当然，**安全序列可能有多个**。

如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了**不安全状态**。这就意味着之后**可能**所有进程都无法顺利地执行下去。当然，如果有进程提前归还了一些资源，那**系统也有可能重新回到安全状态**，不过在分配资源之前总是要考虑最坏的情况。

如果系统处于**安全状态**，就**一定不会**发生**死锁**。如果系统进入**不安全状态**，就**可能**发生**死锁**（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）。

因此可以**在资源分配之前预先判断这次分配是否会导致系统进入不安全状态**，以此决定是否答应资源分配请求，这也是“**银行家算法**”的核心思想。

#### 银行家算法

是荷兰学者Dijkstra为[银行系统](https://docs.drshw.tech/pb/senior/6/#%E9%99%84%E5%BD%95-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95)设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于**避免死锁**。

**基本思想**：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。

一般资源的类型会有很多种，可以使用多维的向量来表示资源的分配情况。

算法示例：系统中有5个进程`P0~P4`，3种资源`R0~R2`，初始数量为`(10, 5, 7)`，则某一时刻的各进程的资源情况可表示如下：

<img src="https://images.drshw.tech/images/notes/image-20221016140806860.png" alt="image-20221016140806860" style="zoom:50%;" />

此时总共已分配`(7, 2, 5)`，还剩余`(3, 3, 2)`。下面将剩余资源数`(3, 3, 2)`与各进程最多还需要分配的资源数进行比较，若三种类型的剩余资源均大于进程最多需要的资源，即可将资源分配给它。按照这样的分配方式，需要尝试找出一个**安全序列**：

按`P0~P4`的顺序，依次检查剩余可用资源`(3, 3, 2)`是否能满足各进程的需求：

> 无法满足`P0`进程，但可满足`P1`进程。若优先将资源分配给`P1`，那么`P1`一定可以顺利执行结束。等`P1`结束了就会归还资源。于是，资源数就可以增加到：`(2, 0, 0) + (3, 3, 2) = (5, 3, 2)`。

于是将`P1`加入安全序列，并更新剩余可用资源值为`(5, 3, 2)`；

依次检查剩余可用资源`(5, 3, 2)`是否能满足剩余进程（**不包括已加入安全序列的进程**）的需求：

> 无法满足`P0`、`P2`进程，但可满足`P3`进程。若优先将资源分配给`P3`，那么`P3`一定可以顺利执行结束。等`P3`结束了就会归还资源。资源数可以增加到`(2, 1, 1) + (5, 3, 2) = (7, 4, 3)`。 

依次检查剩余可用资源`(7, 4, 3)`是否能满足剩余进程（**不包括已加入安全序列的进程**）的需求：

......

以此类推，共五次循环检查即可将5个进程都加入安全序列中，最终可得一个安全序列。该算法称为**安全性算法**。可以很方便地用代码实现以上流程，每一轮检查都从编号较小的进程开始检查。

<img src="https://images.drshw.tech/images/notes/image-20221016142758980.png" alt="image-20221016142758980" style="zoom:50%;" />

再看一个找不到安全序列的例子：该时刻各进程的最大需求修改如下，其余资源设置不变：

<img src="https://images.drshw.tech/images/notes/image-20221016142951182.png" alt="image-20221016142951182" style="zoom: 50%;" />

经对比发现，`(3, 3, 2)`可满足`P1`、`P3`，说明无论如何，这两个进程的资源需求一定是可以依次被满足的，因此`P1`、`P3`一定可以顺利地执行完，并归还资源。可把`P1`、`P3`先加入安全序列。

资源数可以增加到`(2, 1, 1) + (5, 3, 2) = (7, 4, 3)`。

剩下的，`P0`需要`(8, 4, 3)`，`P2`需要`(6, 5, 0)`，`P4`需要`(4, 3, 4)`，任何一个进程都不能被完全满足。

于是，无法找到任何一个安全序列，说明此时系统处于**不安全状态**，**有可能发生死锁**。

#### 代码实现

银行家算法步骤：

1. 检查此次申请是否超过了之前声明的最大需求数；
2. 检查此时系统剩余的可用资源是否还能满足这次请求；
3. 试探着分配，更改各数据结构；
4. 用安全性算法检查此次分配是否会导致系统进入不安全状态。

安全性检查算法步骤：

检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。

不断重复上述过程，看最终是否能让所有进程都加入安全序列。

实现思路：

<img src="https://images.drshw.tech/images/notes/image-20221016143846148.png" alt="image-20221016143846148" style="zoom:50%;" />


C++代码示例：

```cpp
#include <iostream>

using namespace std;

int n, m; // n个进程，m种资源

const int MAX = 100; // 最大进程数

int available[MAX];       // 系统可用资源数
int _max[MAX][MAX];       // 最大需求矩阵
int allocation[MAX][MAX]; // 已分配矩阵
int need[MAX][MAX];       // 还需资源矩阵

int request[MAX]; // 请求向量
bool finish[MAX]; // 是否完成
int safe[MAX]; // 存储安全序列

bool find_senquence()
{
    int work[MAX]; // 可用资源向量
    int count = 0; // 安全序列长度

    // 初始化
    for (int i = 0; i < n; i++)
    {
        work[i] = available[i];
        finish[i] = false;
    }
    // 总资源减去已用资源
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            work[j] -= allocation[i][j];
    // 寻找安全序列
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            if (!finish[j])     // 判断j是否完成，若完成则直接跳过
            {
                int k;
                for (k = 0; k < m; k++)        // 比对各维度的资源，若有一维度不满足则跳出
                    if (need[j][k] > work[k])
                        break;
                if (k == m) 
                {
                    for (k = 0; k < m; k++)
                        work[k] += allocation[j][k];
                    finish[j] = true;
                    safe[count++] = j;
                }
            }

    // 判断是否有安全序列；若所有进程都能成功结束，则存在安全序列
    if (count == n)
        return true;
    else
        return false;
}

int main()
{
    // 参数输入
    cin >> n >> m;
    for (int i = 0; i < m; i++)
        cin >> available[i];
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> _max[i][j];
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> allocation[i][j];
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            need[i][j] = _max[i][j] - allocation[i][j];
    if(find_senquence())  // 判断是否存在安全序列
    {
        cout << "存在安全序列，为：";
        for (int i = 0; i < n; i++)
            cout << safe[i] << " ";
        cout << endl;
    } else
        cout << "无安全序列" << endl;
    return 0;
}
```

### 3.4.4 死锁的检测和解除

<img src="https://images.drshw.tech/images/notes/image-20221016181704712.png" alt="image-20221016181704712" style="zoom:50%;" />

#### 死锁的检测

为了能对系统是否已发生了死锁进行检测，必须：

1. 用某种**数据结构**来保存资源的请求和分配信息；
2. 提供**一种算法**，利用上述信息来检测系统是否已进入死锁状态。

<img src="https://images.drshw.tech/images/notes/image-20221016144642021.png" alt="image-20221016144642021" style="zoom:50%;" />

如下图中`P1`、`P2`节点为**进程结点**，`R1`、`R2`节点为**请求结点**；**请求边**即为进程结点指向资源结点的边，**分配边**即为资源结点指向进程结点的边：

<img src="https://images.drshw.tech/images/notes/image-20221016144736865.png" alt="image-20221016144736865" style="zoom:50%;" />

如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利的执行下去。

如果这个进程执行结束了，就会将所有的资源归还给系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。

相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程。

如上图中，`P1`进程请求了一个`R2`资源，而`R2`资源只被分配了一个，剩余一个，可以满足`P1`。于是我们可以消除所有连接`P1`结点的边（代表请求的完成，资源的归还）：

<img src="https://images.drshw.tech/images/notes/image-20221016145942696.png" alt="image-20221016145942696" style="zoom:50%;" />

此时`P2`也可以被满足，也可以消除与之连接的所有边：

<img src="https://images.drshw.tech/images/notes/image-20221016150102156.png" alt="image-20221016150102156" style="zoom:50%;" />

 此时，所有边都被消除。若最终**能消除所有的边**，就称这个图是**可完全简化的**。此时**一定没有发生死锁**（相当于能找到一个安全序列）。

而如果最终并**不能消除所有边**，那么此时就**发生了死锁**。**最终还连着边的那些进程就是处于死锁状态的进程。**

如下图的例子就发生了死锁：

<img src="https://images.drshw.tech/images/notes/image-20221016150330541.png" alt="image-20221016150330541" style="zoom:50%;" />

图中进程`P3`可以被满足，可将边消去；而`P1`进程请求了两个`R2`资源，而`R2`只剩余一个资源可分配，不能满足`P1`；`P2`进程请求一个`R1`资源，而`R1`资源分配出去三个，无剩余资源，也不能满足`P2`。`P1`、`P2`进程的边无法消除，即`P1`、`P2`处于死锁状态。

于是，死锁检测算法可以归纳总结为：

1. 在资源分配图中，找出既不阻塞又不是孤点的进程`Pi`（即找出一条有向边与它相连，且该有向边对应资源申请数量小于等于系统中已有空闲资源数量。如下图中，`R1`没有空闲资源，`R2`有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配边，使之成为孤立的结点。在下图中，`P1`是满足这一条件的进程结点，于是将`P1`的所有便消去；


2. 进程`Pi`所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在下图中，`P2`就满足这样的条件。根据`1.`中的方法进行一系列化简后，若能消去图中的所有边，则称该图是**可完全简化的**。

   <img src="https://images.drshw.tech/images/notes/image-20221016175000397.png" alt="image-20221016175000397" style="zoom:50%;" />

**死锁定理**：如果某时刻系统的资源分配图是**不可完全简化**的，那么此时系统**死锁**。

#### 死锁的解除

一旦检测出死锁的发生，就应该立即解除死锁。

补充：并非系统中所有的进程都是死锁状态，用死锁检测算法**化简资源分配图后，还连着边的那些进程就是死锁进程**。

解除死锁的主要方法有：

1. **资源剥夺法**。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程，因长时间得不到资源而饥饿；
2. **撤销进程法**（或称**终止进程法**）。强制撤销部分，甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间了，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来；
3. **进程回退法**。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求操作系统记录进程的历史信息，设置还原点。

可以通过以下方面决定被调整的进程：

+ 进程优先级
+ 已执行的时间
+ 剩余执行时间
+ 占用的资源数
+ 进程的工作形式——交互式 or 批处理式(优先被牺牲)
