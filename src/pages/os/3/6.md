---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 3.6 死锁的检测和解除

<img src="https://images.drshw.tech/images/notes/image-20221102182639909.png" alt="image-20221102182639909" style="zoom:33%;" />

### 3.6.1 死锁的检测

为了能对系统是否已发生了死锁进行检测，必须：

1. 用某种**数据结构**来保存资源的请求和分配信息；
2. 提供**一种算法**，利用上述信息来检测系统是否已进入死锁状态。

<img src="https://images.drshw.tech/images/notes/image-20221016144642021.png" alt="image-20221016144642021" style="zoom:50%;" />

如下图中`P1`、`P2`结点为**进程结点**，`R1`、`R2`结点为**请求结点**；**请求边**即为进程结点指向资源结点的边，**分配边**即为资源结点指向进程结点的边：

<img src="https://images.drshw.tech/images/notes/image-20221016144736865.png" alt="image-20221016144736865" style="zoom:50%;" />

如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利的执行下去。

如果这个进程执行结束了，就会将所有的资源归还给系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。

相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程。

如上图中，`P1`进程请求了一个`R2`资源，而`R2`资源只被分配了一个，剩余一个，可以满足`P1`。于是我们可以消除所有连接`P1`结点的边（代表请求的完成，资源的归还）：

<img src="https://images.drshw.tech/images/notes/image-20221016145942696.png" alt="image-20221016145942696" style="zoom:50%;" />

此时`P2`也可以被满足，也可以消除与之连接的所有边：

<img src="https://images.drshw.tech/images/notes/image-20221016150102156.png" alt="image-20221016150102156" style="zoom:50%;" />

此时，所有边都被消除。若最终**能消除所有的边**，就称这个图是**可完全简化的**。此时**一定没有发生死锁**（相当于能找到一个安全序列）。

而如果最终并**不能消除所有边**，那么此时就**发生了死锁**。**最终还连着边的那些进程就是处于死锁状态的进程。**

如下图的例子就发生了死锁：

<img src="https://images.drshw.tech/images/notes/image-20221016150330541.png" alt="image-20221016150330541" style="zoom:50%;" />

图中进程`P3`可以被满足，可将边消去；而`P1`进程请求了两个`R2`资源，而`R2`只剩余一个资源可分配，不能满足`P1`；`P2`进程请求一个`R1`资源，而`R1`资源分配出去三个，无剩余资源，也不能满足`P2`。`P1`、`P2`进程的边无法消除，即`P1`、`P2`处于死锁状态。

于是，死锁检测算法可以归纳总结为：

1. 在资源分配图中，找出既不阻塞又不是孤点的进程`Pi`（即找出一条有向边与它相连，且该有向边对应资源申请数量小于等于系统中已有空闲资源数量。如下图中，`R1`没有空闲资源，`R2`有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配边，使之成为孤立的结点。在下图中，`P1`是满足这一条件的进程结点，于是将`P1`的所有便消去；


2. 进程`Pi`所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在下图中，`P2`就满足这样的条件。根据`1.`中的方法进行一系列化简后，若能消去图中的所有边，则称该图是**可完全简化的**。

   <img src="https://images.drshw.tech/images/notes/image-20221016175000397.png" alt="image-20221016175000397" style="zoom:50%;" />

**死锁定理**：如果某时刻系统的资源分配图是**不可完全简化**的，那么此时系统**死锁**。

### 3.6.2 死锁的解除

一旦检测出死锁的发生，就应该立即解除死锁。

补充：并非系统中所有的进程都是死锁状态，用死锁检测算法**化简资源分配图后，还连着边的那些进程就是死锁进程**。

解除死锁的主要方法有：

1. **资源剥夺法**。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程，因长时间得不到资源而饥饿；
2. **撤销进程法**（或称**终止进程法**）。强制撤销部分，甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间了，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来；
3. **进程回退法**。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求操作系统记录进程的历史信息，设置还原点。

可以通过以下方面决定被调整的进程：

+ 进程优先级
+ 已执行的时间
+ 剩余执行时间
+ 占用的资源数
+ 进程的工作形式——交互式 or 批处理式(优先被牺牲)
