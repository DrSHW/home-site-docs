---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 3.1 处理机调度的基本概念

### 3.1.1 调度与作业的基本概念

#### 调度的概念

当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定**某种规则**，来**决定**处理这些任务的**顺序**，这就是调度“研究”的问题。

在多道程序系统中，进程的数量往往是多于处理机个数的，这样不可能同时并行地处理各个进程。

**处理机调度**，就是从就绪队列中**按照一定的算法选择一个进程**并**将处理机分配给它**运行，以实现进程的并发执行。

#### 作业控制块

**作业控制块（JCB）** 是作业在系统中存在的标志，保存了系统对作业进行管理和调度所需的全部信息。

+ 作业进入系统时：系统为每个作业建立一个JCB，并根据作业类型插入到相应的后备队列，作业调度程序依据一定的调度算法来调度它们。被调度的作业将会**装入内存**；
+ 作业运行期间：系统按照JCB中的信息对作业进行控制；
+ 作业执行结束：系统负责回收分配给它们的资源，撤销JCB。

#### 作业、作业步和作业流

**作业**包含程序、数据和作业说明书。可根据作业说明书对程序的运行进行控制（**作业控制块JCB**）。

**作业步**：典型的作业分为三步：编译作业、连结装配作业、运行作业步。

**作业流**：若干个作业进入系统，存放在外存。

作业和进程的关系如下图所示：

<img src="https://images.drshw.tech/images/notes/image-20221121174933439.png" alt="image-20221121174933439" style="zoom: 33%;" />

### 3.1.2 调度的三个层次

作业从进入系统成为后备作业开始，直到运行结束退出系统为止，需经历不同级别的调度。调度分为**高级调度**、**中级调度**和**低级调度**三个层次：

<img src="https://images.drshw.tech/images/notes/image-20221012235431275.png" alt="image-20221012235431275" style="zoom:60%;" />

#### 高级调度

由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。

**高级调度（作业调度）**：根据JCB中的信息，审查系统能否满足用户作业的资源需求；以及按某种规则，从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并**建立相应的进程（建立PCB）**，以使它（们）**获得竞争处理机的权利**。

这里的“某种规则”，就是后面要讲的[调度算法](https://docs.drshw.tech/os/3/2/)要研究的问题。

高级调度时辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。**作业调入时会建立相应的PCB，作业调出时才撤销PCB。** 高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。

#### 中级调度

引入了[虚拟存储技术](https://docs.drshw.tech/os/5/1/#512-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81)之后，可将暂时不能允许的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。

这么做的目的是为了**提高内存利用率**和**系统吞吐量**，实际上就是存储器管理中的[对换](https://docs.drshw.tech/os/4/1/#%E5%AF%B9%E6%8D%A2%E6%8A%80%E6%9C%AF)功能。

暂时调到外存等待的进程状态为**挂起状态**。值得注意的是，**PCB**并不会一起调到外存，而是**会常驻内存**。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到**挂起队列**中。

<img src="https://images.drshw.tech/images/notes/image-20221012233423458.png" alt="image-20221012233423458" style="zoom:50%;" />

**中级调度（内存调度）**，就是要决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存，因此**中级调度**发生的**频率**要比高级调度**更高**。

#### 低级调度

**低级调度（进程/短程调度）**：调度对象是**进程**，主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。

进程调度是操作系统中**最基本的一种调度**，在一般的操作系统中都必须配置进程调度。进程调度的**频率很高**，一般几十毫秒一次。

主要功能：

1. 保存处理机的现场信息：

   保存当前进程的处理机现场信息，如程序计数器、多个通用寄存器的内容；

2. 按某种算法选取进程；

3. 把处理器分配给进程：

   由分派程序把处理器分配给进程，需要将选中进程的进程控制块内 有关处理机现场的信息，装入处理器相应的各个寄存器中，把处理器控制权交给该进程，让它从上次中断处恢复运行。

总体流程：

<img src="https://images.drshw.tech/images/notes/image-20221121203913998.png" alt="image-20221121203913998" style="zoom:70%;" />

#### 三层调度的联系和对比

<img src="https://images.drshw.tech/images/notes/image-20221012235257463.png" alt="image-20221012235257463" style="zoom:50%;" />

### 3.1.3 进程的挂起态与七状态模型

在上小节中我们讲过，暂时调到外存等待的进程状态为**挂起状态（挂起态，suspend）**。

挂起态又可以进一步细分为**就绪挂起**、**阻塞挂起**两种状态；原就绪态和阻塞态也被称为**活动就绪和活动阻塞**，就绪挂起和阻塞挂起也被称为**静止就绪和静止阻塞**。

进程的**挂起**过程：

+ 当系统中出现了引起进程挂起的事件时，OS将利用挂起原语`suspend`将指定进程或处于阻塞状态的进程**挂起**；
+ `suspend`的执行过程时：首先检查被挂起进程的状态，若处于活动就绪状态，便将其改为**静止就绪**；
+ 对于活动阻塞状态的进程，则将之改为**静止阻塞（原阻塞态）**；
+ 为了方便用户或父进程考察该进程的运行情况，而把该进程的PCB复制到某指定的内存区域；
+ 最后，若被挂起进程正在执行，则转向调度程序重新调度。

进程的**激活**过程：

+ 当系统中发生激活过程的事件时，OS将利用激活原语`active`，将指定进程**激活**。
+ 激活原语先将进程**从外存调入内存**，检查该进程的现行状态。
+ 若是静止就绪，改为**活动就绪**。
+ 若是静止阻塞，改为**活动阻塞**。

完整的七状态模型：

<img src="https://images.drshw.tech/images/notes/image-20221012233926897.png" alt="image-20221012233926897" style="zoom:50%;" />

注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。

有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞进程进一步细分为多个队列。

### 3.1.4 队列调度模型

#### 仅有进程调度的队列模型：

分时操作系统中，通常仅设置了进程调度，用户键入的命令和数据都直接送入内存，按时间片轮转的方式运行，与[三状态模型](https://docs.drshw.tech/os/2/1/#212-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2)对应：

<img src="https://images.drshw.tech/images/notes/image-20221121210139944.png" alt="image-20221121210139944" style="zoom:80%;" />

#### 具有高级调度和低级调度的调度队列模型

设置了多个阻塞队列，与[五状态模型](https://docs.drshw.tech/os/2/1/#212-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2)对应：

<img src="https://images.drshw.tech/images/notes/image-20221121212052454.png" alt="image-20221121212052454" style="zoom:80%;" />

#### 具有三级调度的调度队列模型

设置了静止阻塞、活动阻塞、静止就绪、活动就绪队列，与[七状态模型](https://docs.drshw.tech/os/3/1/#313-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7%E6%80%81%E4%B8%8E%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B)对应：

<img src="https://images.drshw.tech/images/notes/image-20221121221112452.png" alt="image-20221121221112452" style="zoom:80%;" />

### 3.1.5 进程调度的时机

在3.1.2中，我们了解过**进程调度（低级调度）** 的概念——按照某种算法从就绪队列中选择一个进程为其分配处理机。

<img src="https://images.drshw.tech/images/notes/image-20221012235942212.png" alt="image-20221012235942212" style="zoom:50%;" />

要注意的是：进程在操作系统**内核程序临界区**中**不能**进行调度与切换。但是在普通临界区访问的临界资源，不会直接影响操作系统内核的管理工作。因此在访问**普通临界区**时，进程**可以**进行调度与切换。

### 3.1.6 进程调度的方式

进程调度的方式分为**非剥夺调度方式**和**剥夺调度方式**：

<img src="https://images.drshw.tech/images/notes/image-20221013002217143.png" alt="image-20221013002217143" style="zoom:70%;" />

#### 非抢占调度方式

又称**非剥夺方式**，即只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。

特点：实现简单，系统开销小但是无法及时处理紧急任务，适合于**早期的批处理系统**。

#### 抢占调度方式

又称**剥夺方式**。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。

特点：可以优先处理更紧急的进程，也可实现让进程按时间片轮转执行的功能（通过时钟中断），系统开销大（切换时CPU需要改变状态）。适合于**分时操作系统、实时操作系统**。

### 3.1.7 进程的切换与过程

“狭义的进程调度”与“进程切换”的区别：

**狭义的进程调度**指的是：从就绪队列中**选中一个要运行的进程**——这个进程可以是刚被暂停执行的进程，也可能是**另一个进程**。后一种情况就需要**进程切换**。

**广义的进程调度**包含了选择一个进程和进程切换两个步骤。

进程切换的过程主要完成了：

1. 对原来运行进程各种数据的**保存**；
2. 对新的进程各种数据的**恢复**；（如：程序计数器`PC`、程序状态字、各种数据寄存器等处理现场信息，这些信息一般保存在进程控制块`PCB`中）

注意：**进程切换是有代价的**，因此如果**过于频繁地**进行进程**调度**、**切换**，必然会使整个**系统的效率降低**，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。

