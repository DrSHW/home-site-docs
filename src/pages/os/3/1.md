---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 3.1 处理机调度的基本概念

### 3.1.1 调度的基本概念

当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定**某种规则**，来**决定**处理这些任务的**顺序**，这就是调度“研究”的问题。

在多道程序系统中，进程的数量往往是多于处理机个数的，这样不可能同时并行地处理各个进程。

**处理机调度**，就是从就绪队列中**按照一定的算法选择一个进程**并**将处理机分配给它**运行，以实现进程的并发执行。

### 3.1.2 调度的三个层次

进程调度分为**高级调度**、**中级调度**和**低级调度**三个层次：

<img src="https://images.drshw.tech/images/notes/image-20221012235431275.png" alt="image-20221012235431275" style="zoom:60%;" />

#### 高级调度

由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。

**高级调度（作业调度）**：按某种规则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并**建立相应的进程（建立PCB）**，以使它（们）**获得竞争处理机的权利**。

这里的“某种规则”，就是后面要讲的[调度算法](https://docs.drshw.tech/os/3/2/)要研究的问题。

高级调度时辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。**作业调入时会建立相应的PCB，作业调出时才撤销PCB。**高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。

#### 中级调度

引入了虚拟存储技术之后，可将暂时不能允许的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。

这么做的目的是为了**提高内存利用率**和**系统吞吐量**。

暂时调到外存等待的进程状态为**挂起状态**。值得注意的是，**PCB**并不会一起调到外存，而是**会常驻内存**。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到**挂起队列**中。

<img src="https://images.drshw.tech/images/notes/image-20221012233423458.png" alt="image-20221012233423458" style="zoom:50%;" />

**中级调度（内存调度）**，就是要决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存，因此**中级调度**发生的**频率**要比高级调度**更高**。

#### 低级调度

**低级调度（进程调度）**：主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。

进程调度是操作系统中**最基本的一种调度**，在一般的操作系统中都必须配置进程调度。进程调度的**频率很高**，一般几十毫秒一次。

#### 三层调度的联系和对比

<img src="https://images.drshw.tech/images/notes/image-20221012235257463.png" alt="image-20221012235257463" style="zoom:50%;" />

### 3.1.3 进程的挂起态与七状态模型

在上小节中我们讲过，暂时调到外存等待的进程状态为**挂起状态（挂起态，suspend）**。

挂起态又可以进一步细分为**就绪挂起**、**阻塞挂起**两种状态；原就绪态和阻塞态也被称为**活动就绪和活动阻塞**，就绪挂起和阻塞挂起也被称为**静止就绪和静止阻塞**。

进程的**挂起**过程：

+ 当系统中出现了引起进程挂起的事件时，OS将利用挂起原语`suspend`将指定进程或处于阻塞状态的进程**挂起**；
+ `suspend`的执行过程时：首先检查被挂起进程的状态，若处于活动就绪状态，便将其改为**静止就绪**；
+ 对于活动阻塞状态的进程，则将之改为**静止阻塞（原阻塞态）**；
+ 为了方便用户或父进程考察该进程的运行情况，而把该进程的PCB复制到某指定的内存区域；
+ 最后，若被挂起进程正在执行，则转向调度程序重新调度。

进程的**激活**过程：

+ 当系统中发生激活过程的事件时，OS将利用激活原语`active`，将指定进程**激活**。
+ 激活原语先将进程**从外存调入内存**，检查该进程的现行状态。
+ 若是静止就绪，改为**活动就绪**。
+ 若是静止阻塞，改为**活动阻塞**。

完整的七状态模型：

<img src="https://images.drshw.tech/images/notes/image-20221012233926897.png" alt="image-20221012233926897" style="zoom:50%;" />

注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。

有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞进程进一步细分为多个队列。

### 3.1.4 进程调度的时机

在3.1.2中，我们了解过**进程调度（低级调度）**的概念——按照某种算法从就绪队列中选择一个进程为其分配处理机。

<img src="https://images.drshw.tech/images/notes/image-20221012235942212.png" alt="image-20221012235942212" style="zoom:50%;" />

要注意的是：进程在操作系统**内核程序临界区**中**不能**进行调度与切换。但是在普通临界区访问的临界资源，不会直接影响操作系统内核的管理工作。因此在访问**普通临界区**时，进程**可以**进行调度与切换。

### 3.1.5 进程调度的方式

进程调度的方式分为**非剥夺调度方式**和**剥夺调度方式**：

<img src="https://images.drshw.tech/images/notes/image-20221013002217143.png" alt="image-20221013002217143" style="zoom:70%;" />

#### 非剥夺调度方式

又称**非抢占方式**，即只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。

特点：实现简单，系统开销小但是无法及时处理紧急任务，适合于**早期的批处理系统**。

#### 剥夺调度方式

又称**抢占方式**。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。

特点：可以优先处理更紧急的进程，也可实现让进程按时间片轮转执行的功能（通过时钟中断）。适合于**分时操作系统、实时操作系统**。

#### 3.1.6 进程的切换与过程

“狭义的进程调度”与“进程切换”的区别：

**狭义的进程调度**指的是：从就绪队列中**选中一个要运行的进程**——这个进程可以是刚被暂停执行的进程，也可能是**另一个进程**。后一种情况就需要**进程切换**。

**广义的进程调度**包含了选择一个进程和进程切换两个步骤。

进程切换的过程主要完成了：

1. 对原来运行进程各种数据的**保存**；
2. 对新的进程各种数据的**恢复**；（如：程序计数器`PC`、程序状态字、各种数据寄存器等处理现场信息，这些信息一般保存在进程控制块`PCB`中）

注意：**进程切换是有代价的**，因此如果**过于频繁地**进行进程**调度**、**切换**，必然会使整个**系统的效率降低**，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。