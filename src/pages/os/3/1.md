---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 3.1 处理机调度的基本概念

### 3.1.1 调度的基本概念

当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定**某种规则**，来**决定**处理这些任务的**顺序**，这就是调度“研究”的问题。

在多道程序系统中，进程的数量往往是多于处理机个数的，这样不可能同时并行地处理各个进程。

**处理机调度**，就是从就绪队列中**按照一定的算法选择一个进程**并**将处理机分配给它**运行，以实现进程的并发执行。

### 3.1.2 调度的三个层次

进程调度分为**高级调度**、**中级调度**和**低级调度**三个层次：

<img src="https://images.drshw.tech/images/notes/image-20221012235431275.png" alt="image-20221012235431275" style="zoom:60%;" />

#### 高级调度

由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。

**高级调度（作业调度）**：按某种规则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并**建立相应的进程（建立PCB）**，以使它（们）**获得竞争处理机的权利**。

这里的“某种规则”，就是后面要讲的[调度算法](https://docs.drshw.tech/os/3/2/)要研究的问题。

高级调度时辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。**作业调入时会建立相应的PCB，作业调出时才撤销PCB。** 高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。

#### 中级调度

引入了虚拟存储技术之后，可将暂时不能允许的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。

这么做的目的是为了**提高内存利用率**和**系统吞吐量**。

暂时调到外存等待的进程状态为**挂起状态**。值得注意的是，**PCB**并不会一起调到外存，而是**会常驻内存**。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到**挂起队列**中。

<img src="https://images.drshw.tech/images/notes/image-20221012233423458.png" alt="image-20221012233423458" style="zoom:50%;" />

**中级调度（内存调度）**，就是要决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存，因此**中级调度**发生的**频率**要比高级调度**更高**。

#### 低级调度

**低级调度（进程调度）**：主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。

进程调度是操作系统中**最基本的一种调度**，在一般的操作系统中都必须配置进程调度。进程调度的**频率很高**，一般几十毫秒一次。

#### 三层调度的联系和对比

<img src="https://images.drshw.tech/images/notes/image-20221012235257463.png" alt="image-20221012235257463" style="zoom:50%;" />

### 3.1.3 进程的挂起态与七状态模型

在上小节中我们讲过，暂时调到外存等待的进程状态为**挂起状态（挂起态，suspend）**。

挂起态又可以进一步细分为**就绪挂起**、**阻塞挂起**两种状态；原就绪态和阻塞态也被称为**活动就绪和活动阻塞**，就绪挂起和阻塞挂起也被称为**静止就绪和静止阻塞**。

进程的**挂起**过程：

+ 当系统中出现了引起进程挂起的事件时，OS将利用挂起原语`suspend`将指定进程或处于阻塞状态的进程**挂起**；
+ `suspend`的执行过程时：首先检查被挂起进程的状态，若处于活动就绪状态，便将其改为**静止就绪**；
+ 对于活动阻塞状态的进程，则将之改为**静止阻塞（原阻塞态）**；
+ 为了方便用户或父进程考察该进程的运行情况，而把该进程的PCB复制到某指定的内存区域；
+ 最后，若被挂起进程正在执行，则转向调度程序重新调度。

进程的**激活**过程：

+ 当系统中发生激活过程的事件时，OS将利用激活原语`active`，将指定进程**激活**。
+ 激活原语先将进程**从外存调入内存**，检查该进程的现行状态。
+ 若是静止就绪，改为**活动就绪**。
+ 若是静止阻塞，改为**活动阻塞**。

完整的七状态模型：

<img src="https://images.drshw.tech/images/notes/image-20221012233926897.png" alt="image-20221012233926897" style="zoom:50%;" />

注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。

有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞进程进一步细分为多个队列。

### 3.1.4 进程调度的时机

在3.1.2中，我们了解过**进程调度（低级调度）** 的概念——按照某种算法从就绪队列中选择一个进程为其分配处理机。

<img src="https://images.drshw.tech/images/notes/image-20221012235942212.png" alt="image-20221012235942212" style="zoom:50%;" />

要注意的是：进程在操作系统**内核程序临界区**中**不能**进行调度与切换。但是在普通临界区访问的临界资源，不会直接影响操作系统内核的管理工作。因此在访问**普通临界区**时，进程**可以**进行调度与切换。

### 3.1.5 进程调度的方式

进程调度的方式分为**非剥夺调度方式**和**剥夺调度方式**：

<img src="https://images.drshw.tech/images/notes/image-20221013002217143.png" alt="image-20221013002217143" style="zoom:70%;" />

#### 非抢占调度方式

又称**非剥夺方式**，即只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。

特点：实现简单，系统开销小但是无法及时处理紧急任务，适合于**早期的批处理系统**。

#### 抢占调度方式

又称**剥夺方式**。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。

特点：可以优先处理更紧急的进程，也可实现让进程按时间片轮转执行的功能（通过时钟中断）。适合于**分时操作系统、实时操作系统**。

### 3.1.6 进程的切换与过程

“狭义的进程调度”与“进程切换”的区别：

**狭义的进程调度**指的是：从就绪队列中**选中一个要运行的进程**——这个进程可以是刚被暂停执行的进程，也可能是**另一个进程**。后一种情况就需要**进程切换**。

**广义的进程调度**包含了选择一个进程和进程切换两个步骤。

进程切换的过程主要完成了：

1. 对原来运行进程各种数据的**保存**；
2. 对新的进程各种数据的**恢复**；（如：程序计数器`PC`、程序状态字、各种数据寄存器等处理现场信息，这些信息一般保存在进程控制块`PCB`中）

注意：**进程切换是有代价的**，因此如果**过于频繁地**进行进程**调度**、**切换**，必然会使整个**系统的效率降低**，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。

### 3.1.7 调度算法的评价指标

调度算法的评价指标有以下几种：

<img src="https://images.drshw.tech/images/notes/image-20221013215237533.png" alt="image-20221013215237533" style="zoom:60%;" />

#### CPU利用率

由于早期的CPU造价极其昂贵，因此人们会希望让CPU尽可能多地工作，即提高**CPU利用率**。

**CPU利用率**：指CPU“忙碌”的时间占总时间的比例。

<img src="https://images.drshw.tech/images/notes/image-20221013205532207.png" alt="image-20221013205532207" style="zoom:50%;" />

例：某计算机只支持单道程序，某个作业刚开始需要在CPU上运行5秒，再用打印机打印输出5秒，之后再执行5秒，才能结束。在此过程中，CPU利用率、打印机利用率分别是多少？

<img src="https://images.drshw.tech/images/notes/image-20221013205735108.png" alt="image-20221013205735108" style="zoom:50%;" />

#### 系统吞吐量

对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业，即提高**系统吞吐量**。

**系统吞吐量**：单位时间内完成作业的数量。

<img src="https://images.drshw.tech/images/notes/image-20221013210051805.png" alt="image-20221013210051805" style="zoom:50%;" />

例：某计算机系统处理完10道作业，共花费100秒，则系统吞吐量为：<u>10/100 = 0.1 道/秒</u>。

#### 周转时间

对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间，这里的时间即**周转时间**。

**周转时间**：指从作业被提交给系统开始，到作业完成为止的这段时间的间隔。

它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。

<img src="https://images.drshw.tech/images/notes/image-20221013211839827.png" alt="image-20221013211839827" style="zoom:50%;" />

有的作业运行时间短，有的作业运行时间长，因此在周转时间相同的情况下，运行时间不同的作业，给用户的感觉肯定是不一样的。

于是，又引入了**带权周转时间**：

<img src="https://images.drshw.tech/images/notes/image-20221013212149419.png" alt="image-20221013212149419" style="zoom:50%;" />

对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高。

对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高。

#### 等待时间

计算机用户希望自己的作业尽可能少的等待处理机，等待处理机的时间即为等待时间。

**等待时间**：指进程/作业处于**等待处理机状态时间之和**，等待时间越长，用户满意度越低。

<img src="https://images.drshw.tech/images/notes/image-20221013213035460.png" alt="image-20221013213035460" style="zoom:50%;" />

对于**进程**来说，等待时间就是指进程建立后**等待被服务的时间之和**，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。

对于**作业**来说，不仅要考虑**建立进程后的等待时间**，还要加上**作业在外存后备队列中等待的时间**。

一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“**平均等待时间**”来评价整体性能。

#### 响应时间

对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。

**响应时间**：指从用户**提交请求**到**首次产生响应**所用的时间。
