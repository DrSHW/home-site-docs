---
description: Docs intro
layout: ../../../layouts/MainLayout.astro
---

## 3.5 避免死锁

<img src="https://images.drshw.tech/images/notes/image-20221102182734339.png" alt="image-20221102182734339" style="zoom:50%;" />

### 3.5.1 安全序列

所谓**安全序列**，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成（不会存在因超出系统资源上限，而无法满足任一进程的需求的情况）。只要能找出一个安全序列，系统就是**安全状态**。当然，**安全序列可能有多个**。

如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了**不安全状态**。这就意味着之后**可能**所有进程都无法顺利地执行下去。当然，如果有进程提前归还了一些资源，那**系统也有可能重新回到安全状态**，不过在分配资源之前总是要考虑最坏的情况。

如果系统处于**安全状态**，就**一定不会**发生**死锁**。如果系统进入**不安全状态**，就**可能**发生**死锁**（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）。

因此可以**在资源分配之前预先判断这次分配是否会导致系统进入不安全状态**，以此决定是否答应资源分配请求，这也是“**银行家算法**”的核心思想。

### 3.5.2 银行家算法

是荷兰学者Dijkstra为[银行系统](https://docs.drshw.tech/pb/senior/6/#%E9%99%84%E5%BD%95-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95)设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于**避免死锁**。

**基本思想**：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待，否则分配。

一般资源的类型会有很多种，可以使用多维的向量来表示资源的分配情况。

算法示例：系统中有5个进程`P0~P4`，3种资源`R0~R2`，初始数量为`(10, 5, 7)`，则某一时刻的各进程的资源情况可表示如下：

<img src="https://images.drshw.tech/images/notes/image-20221016140806860.png" alt="image-20221016140806860" style="zoom:50%;" />

此时总共已分配`(7, 2, 5)`，还剩余`(3, 3, 2)`。下面将剩余资源数`(3, 3, 2)`与各进程最多还需要分配的资源数进行比较，若三种类型的剩余资源均大于进程最多需要的资源，即可将资源分配给它。按照这样的分配方式，需要尝试找出一个**安全序列**：

按`P0~P4`的顺序，依次检查剩余可用资源`(3, 3, 2)`是否能满足各进程的需求：

> 无法满足`P0`进程，但可满足`P1`进程。若优先将资源分配给`P1`，那么`P1`一定可以顺利执行结束。等`P1`结束了就会归还资源。于是，资源数就可以增加到：`(2, 0, 0) + (3, 3, 2) = (5, 3, 2)`。

于是将`P1`加入安全序列，并更新剩余可用资源值为`(5, 3, 2)`；

依次检查剩余可用资源`(5, 3, 2)`是否能满足剩余进程（**不包括已加入安全序列的进程**）的需求：

> 无法满足`P0`、`P2`进程，但可满足`P3`进程。若优先将资源分配给`P3`，那么`P3`一定可以顺利执行结束。等`P3`结束了就会归还资源。资源数可以增加到`(2, 1, 1) + (5, 3, 2) = (7, 4, 3)`。 

依次检查剩余可用资源`(7, 4, 3)`是否能满足剩余进程（**不包括已加入安全序列的进程**）的需求：

......

以此类推，共五次循环检查即可将5个进程都加入安全序列中，最终可得一个安全序列。该算法称为**安全性算法**。可以很方便地用代码实现以上流程，每一轮检查都从编号较小的进程开始检查。

<img src="https://images.drshw.tech/images/notes/image-20221016142758980.png" alt="image-20221016142758980" style="zoom:50%;" />

再看一个找不到安全序列的例子：该时刻各进程的最大需求修改如下，其余资源设置不变：

<img src="https://images.drshw.tech/images/notes/image-20221016142951182.png" alt="image-20221016142951182" style="zoom: 50%;" />

经对比发现，`(3, 3, 2)`可满足`P1`、`P3`，说明无论如何，这两个进程的资源需求一定是可以依次被满足的，因此`P1`、`P3`一定可以顺利地执行完，并归还资源。可把`P1`、`P3`先加入安全序列。

资源数可以增加到`(2, 1, 1) + (5, 3, 2) = (7, 4, 3)`。

剩下的，`P0`需要`(8, 4, 3)`，`P2`需要`(6, 5, 0)`，`P4`需要`(4, 3, 4)`，任何一个进程都不能被完全满足。

于是，无法找到任何一个安全序列，说明此时系统处于**不安全状态**，**有可能发生死锁**。

### 3.5.3 代码实现

银行家算法步骤：

1. 检查此次申请是否超过了之前声明的最大需求数；
2. 检查此时系统剩余的可用资源是否还能满足这次请求；
3. 试探着分配，更改各数据结构；
4. 用安全性算法检查此次分配是否会导致系统进入不安全状态。

安全性检查算法步骤：

检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。

不断重复上述过程，看最终是否能让所有进程都加入安全序列。

实现思路：

<img src="https://images.drshw.tech/images/notes/image-20221016143846148.png" alt="image-20221016143846148" style="zoom:50%;" />


使用C++编写银行家算法的基本逻辑：

```cpp
#include <iostream>

using namespace std;

int n, m; // n个进程，m种资源

const int MAX = 100; // 最大进程数

int available[MAX];       // 系统可用资源数
int _max[MAX][MAX];       // 最大需求矩阵
int allocation[MAX][MAX]; // 已分配矩阵
int need[MAX][MAX];       // 还需资源矩阵

int request[MAX]; // 请求向量
bool finish[MAX]; // 是否完成
int safe[MAX]; // 存储安全序列

bool find_senquence()
{
    int work[MAX]; // 可用资源向量
    int count = 0; // 安全序列长度
    // 初始化
    for (int i = 0; i < n; i++)
    {
        work[i] = available[i];
        finish[i] = false;
    }
    // 总资源减去已用资源
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            work[j] -= allocation[i][j];
    // 寻找安全序列
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            if (!finish[j])     // 判断j是否完成，若完成则直接跳过
            {
                int k;
                for (k = 0; k < m; k++) // 比对各维度的资源，任一维度不满足则跳出
                    if (need[j][k] > work[k])
                        break;
                if (k == m) 
                {
                    for (k = 0; k < m; k++)
                        work[k] += allocation[j][k];
                    finish[j] = true;
                    safe[count++] = j;
                }
            }
    // 判断是否有安全序列；若所有进程都能成功结束，则存在安全序列
    if (count == n)
        return true;
    else
        return false;
}

int main()
{
    // 参数输入
    cin >> n >> m;
    for (int i = 0; i < m; i++)
        cin >> available[i];
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> _max[i][j];
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> allocation[i][j];
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            need[i][j] = _max[i][j] - allocation[i][j];
    if(find_senquence())  // 判断是否存在安全序列
    {
        cout << "存在安全序列，为：";
        for (int i = 0; i < n; i++)
            cout << safe[i] << " ";
        cout << endl;
    } else
        cout << "无安全序列" << endl;
    return 0;
}
```

测试示例1

输入：
```
5 3
10 5 7
7 5 3
3 2 2
9 0 2
2 2 2
4 3 3
0 1 0
2 0 0
3 0 2
2 1 1
0 0 2
```
输出：
```
存在安全序列，为：1 3 4 0 2
```

测试示例2

输入：
```
5 3
10 5 7
8 5 3 
3 2 2
9 5 2
2 2 2
4 3 6
0 1 0
2 0 0
3 0 2
2 1 1
0 0 2
```
输出：
```
无安全序列
```

例题见本小节[本章疑难点](https://docs.drshw.tech/os/3/final/#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95)。
